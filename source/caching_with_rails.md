Кэширование с Rails: Обзор
==========================

Это руководство научит вас, что нужно знать для избежания чрезмерного обращения к базе данных и возвращении того, что нужно возвратить веб клиентам за максимально короткое время.

После прочтения этого руководства, вы узнаете:

* О кэширование страниц и экшнов (вынесены в отдельный гем, начиная с Rails 4).
* Кэширование фрагмента
* Об альтернативных хранилищах кэша.
* Об условной поддержке GET.

Основы кэширования
------------------

Это введение в три типа техники кэширования: кэширование страницы, экшна и фрагмента. По умолчанию Rails предоставляет кэширование фрагмента. Чтобы использовать кэширование страницы и экшна, нужно добавить `actionpack-page_caching` и `actionpack-action_caching` в свой Gemfile.

Перед тем, как начать, убедитесь, что `config.action_controller.perform_caching` установлен `true`, если запущен режим development. Этот флаг обычно устанавливается в соответствующем config/environments/*.rb. По умолчанию кэширование отключено для development и test и включено для production.

```ruby
config.action_controller.perform_caching = true
```

### Кэширование страницы

Кэширование страницы это механизм Rails, позволяющий запросу на сгенерированную страницу быть полностью обслуженным вебсервером (т.е. Apache или nginx) в принципе, без прохождения через стек Rails. Очевидно, это очень быстро. К сожалению, это не может быть применено к каждой ситуации (например, к страницам, требующим аутентификации), и, так как вебсервер фактически извлекает файл из файловой системы, придется иметь дело с вопросом времени хранения кэша.

INFO: Кэширование страниц было убрано из Rails 4. Обратитесь к [гему actionpack-page_caching](https://github.com/rails/actionpack-page_caching). Так же взгляните на статью [DHH по прекращению кэша, основанного на ключе](http://37signals.com/svn/posts/3113-how-key-based-cache-expiration-works), как более предпочтительного способа.

### Кэширование экшна

Кэширование страниц нельзя использовать для экшнов, имеющих предварительные фильтры, - например, для страниц, требующих аутентификации. И тут на помощь приходит кэширование экшна. Кэширование экшна работает как кэширование страницы, за исключением того, что входящий веб запрос затрагивает стек Rails, таким образом, до обслуживания кэша могут быть запущены предварительные (before) фильтры. Это позволит использовать аутентификацию и другие ограничения, и в то же время выводит результат из кэшированной копии.

INFO: Кэширование экшна было убрано из Rails 4. Обратитесь к [гему actionpack-action_caching](https://github.com/rails/actionpack-action_caching). Так же взгляните на статью [DHH по прекращению кэша, основанного на ключе](http://37signals.com/svn/posts/3113-how-key-based-cache-expiration-works), как более предпочтительного способа.

### Кэширование фрагмента

Жить было бы прекрасно, если бы мы могли закэшировать весь контент страницы или экшна и обслуживать с ним всех. К сожалению, динамические веб приложения обычно создают страницы с рядом компонентов, не все из которых имеют сходные характеристики кэширования. Для устранения таких динамически создаваемых страниц, где различные части страниц нуждаются в кэшировании и прекращаются по-разному, Rails предоставляет механизм, названный Кэширование фрагмента.

Кэширование фрагмента позволяет фрагменту логики вьюхи быть обернутым в блок кэша и обслуженным из хранилища кэша для последующего запроса.

Как пример, если хотите показать все заказы, размещенные на веб сайте, в реальном времени и не хотите кэшировать эту часть страницы, но хотите кэшировать часть страницы, отображающей все доступные продукты, можете использовать следующий кусок кода:

```ruby
<% Order.find_recent.each do |o| %>
  <%= o.buyer.name %> bought <%= o.product.name %>
<% end %>

<% cache do %>
  All available products:
  <% Product.all.each do |p| %>
    <%= link_to p.name, product_url(p) %>
  <% end %>
<% end %>
```

Блок cache в нашем примере будет привязан к вызвавшему его экшну и записан в тоже место, как кэш экшна, что означает, что если хотите кэшировать несколько фрагментов на экшн, следует предоставить `action_suffix` в вызове cache:

```ruby
<% cache(action: 'recent', action_suffix: 'all_products') do %>
  All available products:
```

Можете прекратить кэш, используя метод `expire_fragment`, подобно следующему:

```ruby
expire_fragment(controller: 'products', action: 'recent', action_suffix: 'all_products')
```

Если не хотите, чтобы блок cache привязывался к вызвавшему его экшну, можете также использовать глобально настроенные фрагменты, вызвав метод `cache` с ключом, следующим образом:

```ruby
<% cache('all_available_products') do %>
  All available products:
<% end %>
```

Этот фрагмент затем будет доступен во всех экшнах в `ProductsController` c использованием ключа, и может быть прекращен тем же образом:

```ruby
expire_fragment('all_available_products')
```

Если хотите избежать ручного прекращения фрагмента всякий раз, когда экшн обновляет продукт, можно определить метод хелпера:

```ruby
module ProductsHelper
  def cache_key_for_products
    count          = Product.count
    max_updated_at = Product.maximum(:updated_at).try(:utc).try(:to_s, :number)
    "products/all-#{count}-#{max_updated_at}"
  end
end
```

Этот метод создает ключ кэша, зависящий от всех продуктов, и может быть использован во вьюхе:

```erb
<% cache(cache_key_for_products) do %>
  All available products:
<% end %>
```

В качестве ключа кэша можно использовать модель Active Record:

```erb
<% Product.all.each do |p| %>
  <% cache(p) do %>
    <%= link_to p.name, product_url(p) %>
  <% end %>
<% end %>
```

Для модели будет вызван метод `cache_key`, возвращающий строку наподобие `products/23-20130109142513`. Ключ кэша включает имя модели, id и, наконец, временную метку updated_at. Таким образом, он автоматически создаст новый фрагмент, когда продукт обновится, так как ключ изменится.

Можно также объединить две схемы, что называется "Russian Doll Caching":

```erb
<% cache(cache_key_for_products) do %>
  All available products:
  <% Product.all.each do |p| %>
    <% cache(p) do %>
      <%= link_to p.name, product_url(p) %>
    <% end %>
  <% end %>
<% end %>
```

Это называется "Russian Doll Caching", так как оно вкладывает несколько фрагментов. Преимущество этого в том, что если обновится единственный продукт, все другие внутренние фрагменты будут использованы повторно при создании внешнего фрагмента.

### Кэширование SQL

Кэширование запроса это особенность Rails, кэширующая результат выборки по каждому запросу. Если Rails встретит тот же запрос (query) на протяжения текущего запроса (request), он использует кэшированный результат, вместо того, чтобы снова сделать запрос к базе данных.

Например:

```ruby
class ProductsController < ApplicationController

  def index
    # Запускаем поисковый запрос
    @products = Product.all

    ...

    # Снова запускаем тот же запрос
    @products = Product.all
  end

end
```

Хранилища кэша
--------------

Rails предоставляет различные хранилища для кэшированных данных, созданных кэшами <b>экшна</b> или <b>фрагмента.</b>

TIP: Кэши страницы всегда сохраняются на диск.

### Конфигурация

Можно настроить хранилище кэша по умолчанию своего приложения, вызвав `config.cache_store=` в описании Application в файле `config/application.rb` или в блоке Application.configure в файле конфигурации определенной среды (т.е. `config/environments/*.rb`). Первый аргумент будет используемым хранилищем кэша, остальные будут переданы как аргументы в конструктор хранилища кэша.

```ruby
config.cache_store = :memory_store
```

NOTE: Альтернативно можно вызвать `ActionController::Base.cache_store` вне конфигурационного блока.

К кэшу можно получить доступ, вызвав `Rails.cache`.

### ActiveSupport::Cache::Store

Этот класс представляет основу для взаимодействия с кэшем в Rails. Это абстрактный класс, и его самого нельзя использовать. Вместо него нужно использовать конкретную реализацию класса, связанного с engine-ом хранилища. Rails поставляется с несколькими реализациями, документированными ниже.

Главные вызываемые методы это `read`, `write`, `delete`, `exist?` и `fetch`. Метод fetch принимает блок и либо возвращает существующее значение из кэша, либо вычисляет блок и записывает результат в кэш, если значения не существует.

Имеется несколько общих опций, используемых всеми реализациями кэша. Они могут переданы в конструктор или различные методы для взаимодействия с записями.

* `:namespace` - Эта опция может быть использована для создания пространства имен в хранилище кэша. Она особенно полезна, если приложение разделяет кэш с другим приложением. Значение по умолчанию включает имя приложения и среду Rails.

* `:compress` - Эта опция может быть использована для указания, что в кэше должно быть использовано сжатие. Это особенно полезно для передачи огромных записей кэша по медленной сети.

* `:compress_threshold` - Эта опция используется в сочетании с опцией <tt>:compress</tt> для указания порога, до которого записи кэша не будут сжиматься. По умолчанию 16 килобайт.

* `:expires_in` - Эта опция устанавливает время прекращения в секундах для записи кэша, когда она будет автоматически убрана из кэша.

* `:race_condition_ttl` - Эта опция используется в сочетании с опцией `:expires_in`. Она предотвращает гонку условий при прекращении записи кэша, предотвращая несколько процессов от одновременного пересоздания одной и той же записи (также известного как dog pile effect). Эта опция устанавливает количество секунд, в течение которых прекращенная запись кэша может использоваться, пока не будет пересоздана новая запись. Считается хорошей практикой установить это значение, если используется опция `:expires_in`.

### ActiveSupport::Cache::MemoryStore

Это хранилище кэша хранит записи в памяти в том же процессе Ruby. У хранилища кэша ограниченный размер, определенный опциями `:size` в инициализаторе (по умолчанию 32Mb). Когда кэш превышает выделенный размер, происходит очистка и наиболее давно используемые записи будут убраны.

```ruby
config.cache_store = :memory_store, { size: 64.megabytes }
```

Если запущено несколько среверных процессов Ruby on Rails (что бывает в случае использования mongrel_cluster или Phusion Passenger), то экземпляры ваших серверов Rails не смогут разделять данные кэша друг с другом. Это хранилище кэша не подходит для больших приложений, но замечательно работает с небольшими, низко-траффиковыми сайтами с несколькими серверными процессами, или для сред development и test.

### ActiveSupport::Cache::FileStore

Это хранилище кэша использует файловую систему для хранения записей. Путь к директории, в которой будут храниться файлы, должен быть определен при инициализации кэша.

```ruby
config.cache_store = :file_store, "/path/to/cache/directory"
```

С этим хранилищем кэша несколько серверных процессов на одном хосте могут делиться кэшем. Серверные процессы, запущенные на разных хостах, могут делиться кэшем при использовании общей файловой системы, но эта настройка не идеальна и не рекомендована. Хранилище кэша подходит для сайтов со трафиком до среднего, обслуживающихся на одном - двух хостах.

Отметьте, что хэш будет рости, пока не заполнится диск, если периодически не чистить старые записи.

Это реализация хранилища кэша по умолчанию.

### ActiveSupport::Cache::MemCacheStore

Это хранилище кэша использует сервер Danga's `memcached` для предоставления централизованного кэша вашему приложению. Rails по умолчанию использует встроенный гем `dalli`. Сейчас это наиболее популярное хранилище кэша для работающих вебсайтов. Оно представляет отдельный общий кластер кэша с очень высокими производительностью и резервированием.

При инициализации кэша необходимо указать адреса для всех серверов memcached в вашем кластере. Если ни один не определен, предполагается, что memcached запущен на локальном хосте на порте по умолчанию, но это не идеальная настройка для больших сайтов.

Методы `write` и `fetch` на кэше принимают две дополнительных опции, дающие преимущества особенностей memcached. Можно определить `:raw` для отправки значения на сервер без сериализации. Значение должно быть строкой или числом. Прямые операции memcached, такие как `increment` и `decrement`, можно использовать только на значениях raw. Также можно определить `:unless_exist`, если не хотите, чтобы memcached перезаписал существующую запись.

```ruby
config.cache_store = :mem_cache_store, "cache-1.example.com", "cache-2.example.com"
```

### ActiveSupport::Cache::EhcacheStore

При использовании JRuby можно использовать Terracotta's Ehcache как хранилище кэша вашего приложения. Ehcache это Java кэш с открытым исходным кодом, также предлагается версия enterprise с улучшенными масштабируемостью, управлением и коммерческой поддержкой. Для использования этого хранилища кэша, сначала необходимо установить гем jruby-ehcache-rails3 (версия 1.1.0 или выше).

```ruby
config.cache_store = :ehcache_store
```

при инициализации кэша можно использовать опцию `:ehcache_config` для определения используемого конфигурационного файла Ehcache (по умолчанию "ehcache.xml" в директории config Rails), и опцию :cache_name для предоставления произвольного имени вашего кэша (по умолчанию rails_cache).

В дополнение к стандартной опции `:expires_in`, метод `write` в этом кэше также принимает дополнительную опцию `:unless_exist`, что приводит к тому, что хранилище кэша будет использовать метод Ehcache `putIfAbsent` вместо `put`, и, следовательно, не перезапишет существующую запись. Дополнительно метод `write` поддерживает все свойства, раскрытые в [классе Ehcache Element](http://ehcache.org/apidocs/net/sf/ehcache/Element.html), включая:

| Свойство                    | Тип аргумента       | Описание                                                     |
| --------------------------- | ------------------- | ------------------------------------------------------------ |
| elementEvictionData         | ElementEvictionData | Устанавливает истребование экземпляра данных этого элемента. |
| eternal                     | boolean             | Устанавливает, является ли элемент вечным.                   |
| timeToIdle, tti             | int                 | Устанавливает время бездействия                              |
| timeToLive, ttl, expires_in | int                 | Устанавливает время жизни                                    |
| version                     | long                | Устанавливает атрибут версии объекта ElementAttributes.      |

Эти опции передаются в метод `write` как хэш, с использованием написания либо camelCase, либо с подчеркиваниями, как в следующих примерах:

```ruby
Rails.cache.write('key', 'value', time_to_idle: 60.seconds, timeToLive: 600.seconds)
caches_action :index, expires_in: 60.seconds, unless_exist: true
```

Подробнее об Ehcache смотрите на [http://ehcache.org/](http://ehcache.org/).
Подробнее об Ehcache для JRuby and Rails смотрите [http://ehcache.org/documentation/jruby.html](http://ehcache.org/documentation/jruby.html)

### ActiveSupport::Cache::NullStore

Эта реализация хранилища кэша предполагает использование только в средах development или test, и никогда ничего не хранит. Это может быть полезным при разработке, когда у вас имеется код, взаимодеюствующий непосредственно с `Rails.cache`, но кэширование может препятствовать способности видеть результат изменений в коде. С помощью этого хранилища кэша все операции `fetch` и `read` приведут к отсутствующему результату.

```ruby
config.cache_store = :null_store
```

### Произвольные хранилища кэша

Можно создать свое собственно хранилище кэша, просто расширив `ActiveSupport::Cache::Store` и реализовав соответствующие методы. Таким образом можно применить несколько кэширующих технологий в вашем приложении Rails.

Для использования произвольного хранилища кэша просто присвойте хранилищу кэша новый экземпляр класса.

```ruby
config.cache_store = MyCacheStore.new
```

### Ключи кэша

Ключи, используемые в кэше могут быть любым объектом, отвечающим либо на `:cache_key`, либо на `:to_param`. Можно реализовать метод `:cache_key в своем классе, если необходимо создать произвольный класс. Active Record создает ключи, основанные на имени класса и id записи.

Как ключи хэша можно использовать хэши и массивы.

```ruby
# Это правильный ключ хэша
Rails.cache.read(site: "mysite", owners: [owner_1, owner_2])
```

Ключи, используемые на `Rails.cache` не те же самые, что фактически используются движком хранения. Они могут быть модифицированы пространством имен, или изменены в соответствии с ограничениями технологии. Это значит, к примеру, что нельзя сохранить значения с помощью `Rails.cache`, а затем попытаться вытащить их с помощью гема `memcache-client`. Однако, также не стоит беспокоиться о превышения лимита memcached или несоблюдении правил синтаксиса.

Поддержка GET с условием (Conditional GET)
------------------------------------------

GET с условием это особенность спецификации HTTP, предоставляющая способ вебсерверам сказать браузерам, что отклик на запрос GET не изменился с последнего запроса и может быть спокойно извлечен из кэша браузера.

Это работает с использованием заголовков HTTP_IF_NONE_MATCH и HTTP_IF_MODIFIED_SINCE для передачи туда-обратно уникального идентификатора контента и временной метки, когда содержимое было последний раз изменено. Если браузер делает запрос, в котором идентификатор контента (etag) или временная метка последнего изменения соответствует версии сервера, то серверу всего лишь нужно вернуть пустой отклик со статусом not modified.

Это обязанность сервера (т.е. наша) искать временную метку последнего изменения и заголовок if-none-match, и определять, нужно ли отсылать полный отклик. С поддержкой conditional-get в Rails это очень простая задача:

```ruby
class ProductsController < ApplicationController

  def show
    @product = Product.find(params[:id])

    # Если запрос устарел в соответствии с заданной временной меткой или значением
    # etag (т.е. нуждается в обработке снова), тогда запускаем этот блок
    if stale?(last_modified: @product.updated_at.utc, etag: @product.cache_key)
      respond_to do |wants|
        # ... обычное создание отклика
      end
    end

    # Если запрос свежий (т.е. не изменился), то не нужно ничего делать
    # Рендер по умолчанию проверит это, используя параметры,
    # использованные в предыдущем вызове stale?, и автоматически пошлет
    # :not_modified.  И на этом все.
  end
end
```

Вместо хэша опций можно просто передать модель, Rails будет использовать методы `updated_at` и `cache_key` для настройки `last_modified` и `etag`:

```ruby
class ProductsController < ApplicationController
  def show
    @product = Product.find(params[:id])
    respond_with(@product) if stale?(@product)
  end
end
```

Если отсутствует специальная обработка отклика и используется дефолтный механизм рендеринга (т.е. вы не используете respond_to или вызываете сам render), то можете использовать простой хелпер fresh_when:

```ruby
class ProductsController < ApplicationController

  # Это автоматически отошлет :not_modified, если запрос свежий,
  # и отрендерит дефолтный шаблон (product.*), если он устарел.

  def show
    @product = Product.find(params[:id])
    fresh_when last_modified: @product.published_at.utc, etag: @product
  end
end
```
