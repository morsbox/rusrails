Основы Active Record
====================

Это руководство является введением в Active Record.

После прочтения этого руководства, вы узнаете:

* Что такое ORM (Object Relational Mapping) и Active Record, и как они используются в Rails.
* Как Active Record вписывается в парадигму Model-View-Controller.
* Как использовать модели Active Record для управления информацией, хранящейся в реляционной базе данных.
* О соглашении по именованиям схемы Active Record.
* О концепциях миграций базы данных, валидаций и колбэков.

Что такое Active Record?
----------------------

Active Record это M в [MVC](getting_started.html#the-mvc-architecture) - модель - которая является слоем в системе, ответственным за представление бизнес-логики и данных. Active Record упрощает создание и использование бизнес-объектов, данные которых требуют постоянного хранения в базе данных. Сама по себе эта реализация паттерна Active Record является описанием системы ORM (Object Relational Mapping).

### Паттерн Active Record

[Active Record был описан Martin Fowler](http://www.martinfowler.com/eaaCatalog/activeRecord.html) в его книге _Patterns of Enterprise Application Architecture_. В Active Record объекты содержат и сохраненные данные, и поведение, которое работает с этими данными. Active Record исходит из мнения, что обеспечение логики доступа к данным как части объекта покажет пользователям этого объекта то, как читать и писать в базу данных.

### Object Relational Mapping (ORM)

Object-Relational Mapping, обычно упоминающееся как аббревиатура ORM, это техника, соединяющая сложные объекты приложения с таблицами в системе управляения реляционными базами данных. С использованием ORM, свойства и взаимоотношения этих объектов приложения могут быть с легкостью сохранены и получены из базы данных без непосредственного написания выражений SQL, и, в итоге, с меньшим суммарным кодом для доступа в базу данных.

### Active Record это фреймворк ORM

Active Record предоставляет нам несколько механизмов, наиболее важными из которых является способности для:

* Представления моделей и их данных
* Представления связей между этими моделями
* Представления иерархий наследования с помощью связанных моделей
* Валидации моделей до того, как они будут сохранены в базу данных
* Выполнения операций с базой данных в объктно-ориентированном стиле.

Соглашения над конфигурацией в Active Record
----------------------------------------------

При написании приложения с использованием других языков программирования или фреймворков часто требуется писать много конфигурационного кода. В частности, это справедливо для фреймворков ORM. Однако, если следовать соглашениям, принятым Rails, вам придется написать совсем немного конфигураций (а иногда совсем не придется) при создании моделей Active Record. Идея в том, что в большинстве случаев вы настраиваете свои приложения одинаковым образом, и этот способ должен быть способом по умолчанию. Таким образом, явная конфигурация потребуется только тогда, когда вы не следуете соглашениям по какой-то причине.

### Соглашения по именованию

По умолчанию Active Record использует некоторые соглашения по именованию чтобы узнать, как должна быть создана связь между моделями и таблицами базы данных. Rails образует множественное число для имен класса, чтобы найти соответствующую таблицу базы данных. Так, для класса `Book` следует создать таблицу базы данных с именем **books**. Механизмы образования множественного числа Rails очень мощные, они способны образовывать множественное (и единственное) число как для правильных, так и для неправильных слов. При использовании имен класса, созданных из двух и более слов, имя класса модели должно следовать соглашениям Ruby, используя форму CamelCase, тогда как имя таблицы должно содержать слова, разделенные знаком подчеркивания. Примеры:

* Таблица базы данных - Множественная форма со словами, разделенными знаком подчеркивания (т.е., `book_clubs`)
* Класс модели - Единственное число с первой прописной буквой в каждом слове (т.е., `BookClub`)

| Модель / Класс | Таблица / Схема |
| -------------- | --------------- |
| `Post`         | `posts`         |
| `LineItem`     | `line_items`    |
| `Deer`         | `deer`          |
| `Mouse`        | `mice`          |
| `Person`       | `people`        |


### Соглашения схемы

Active Record использует соглашения о именовании для столбцов в таблицах базы данных, зависящих от назначения этих столбцов.

* **Внешние ключи** - Эти поля должны именоваться по образцу `singularized_table_name_id` (т.е., `item_id`, `order_id`). Это поля, которые ищет Active Record при создании связей между вашими моделями.
* **Первичные ключи** - По умолчанию Active Record использует числовой столбец с именем `id` как первичный ключ таблицы. Этот столбец будет автоматически создан при использовании [миграций Rails](/rails-database-migrations) для создания таблиц.

Также имеются некоторые опциональные имена столбцов, создающие дополнительные особенности для экземпляров Active Record:

* `created_at` - Автоматически будут установлены текущие дата и время при изначальном создании записи.
* `updated_at` - Автоматически будут установлены текущие дата и время всякий раз, когда обновляется запись.
* `lock_version` - Добавляет [оптимистичную блокировку](http://api.rubyonrails.org/classes/ActiveRecord/Locking.html) к модели.
* `type` - Указывает, что модель использует [Single Table Inheritance](http://api.rubyonrails.org/classes/ActiveRecord/Base.html)
* `(association_name)_type` - Хранит тип для [полиморфных связей](/active-record-associations#polymorphic-associations).
* `(table_name)_count` - Используется для кэширования количества принадлежных по связи объектов. Например, столбец `comments_count` в классе `Post`, у которого может быть несколько связанных экземпляров `Comment`, закэширует количество существующих комментариев для каждой публикации.

NOTE: Хотя эти имена столбцов опциональны, фактически они зарезервированы Active Record. Избегайте зарезервированных ключевых слов, если вы не желаете дополнительной функциональности. Например, `type` - это зарезервированное слово для определения таблицы, использующей Single Table Inheritance (STI). Если вы не используете STI, попытайтесь использовать аналогичное слово, такое как "context", которое также может аккуратно описать данные, которые вы моделируете.

Создание моделей Active Record
------------------------------

Создавать модели Active Record очень просто. Все, что необходимо сделать, - это создать подкласс `ActiveRecord::Base`, и готово:

```ruby
class Product < ActiveRecord::Base
end
```

Это создаст модель `Product`, связав ее с таблицей `products` в базе данных. Сделав так, также появится способность связать столбцы каждой строки этой таблицы с атрибутами экземпляров вашей модели. Допустим, что таблица `products` была создана с использованием такого выражения SQL:

```sql
CREATE TABLE products (
   id int(11) NOT NULL auto_increment,
   name varchar(255),
   PRIMARY KEY  (id)
);
```

Следуя вышеуказанной схеме, можно будет писать подобный код:

```ruby
p = Product.new
p.name = "Some Book"
puts p.name # "Some Book"
```

Переопределение соглашений о именовании
---------------------------------------

Но что, если вы следуете другому соглашению по именованию или используете новое приложение Rails со старой базой данных? Не проблема, можно просто переопределить соглашения по умолчанию.

Можно использовать метод `ActiveRecord::Base.table_name=` для указания имени таблицы, которая должна быть использована:

```ruby
class Product < ActiveRecord::Base
  self.table_name = "PRODUCT"
end
```

Если так сделать, нужно вручную определить имя класса, содержащего фикстуры (class_name.yml), используя метод `set_fixture_class` в определении теста:

```ruby
class FunnyJoke < ActiveSupport::TestCase
  set_fixture_class funny_jokes: 'Joke'
  fixtures :funny_jokes
  ...
end
```

Также возможно переопределить столбец, который должен быть использован как первичный ключ таблицы, с помощью метода `ActiveRecord::Base.set_primary_key`:

```ruby
class Product < ActiveRecord::Base
  set_primary_key "product_id"
end
```

CRUD: Чтение и запись данных
----------------------------

CRUD это сокращение для четерех глаголов, используемых для описания операций с данными: **C**reate (создать), **R**ead (прочесть), **U**pdate (обновить) и **D**elete (удалить). Active Record автоматически создает методы, позволяющие приложению читать и воздействовать на данные, хранимые в своих таблицах.

### Создание

Объекты Active Record могут быть созданы из хэша, блока или из вручную указанных после создания атрибутов. Метод `new` возвратит новый объект, в то время как `create` возвратит объект и сохранит его в базу данных.

Например, для модели `User` с атрибутами `name` и `occupation`, вызов метода `create` создаст и сохранит новую запись в базу данных:

```ruby
user = User.create(name: "David", occupation: "Code Artist")
```

Используя метод `new`, объект может быть инициализирован без сохранения:

```ruby
user = User.new
user.name = "David"
user.occupation = "Code Artist"
```

Вызов `user.save` передаст запись в базу данных.

Наконец, если представлен блок и `create`, и `new` передадут новый объект в этот блок для инициализации:

```ruby
user = User.new do |u|
  u.name = "David"
  u.occupation = "Code Artist"
end
```

### Чтение

Active Record предоставляет богатый API для доступа к данным в базе данных. Ниже несколько примеров различных методов доступа к данным, представленных Active Record.

```ruby
# возвратит коллекцию со всеми пользователями
users = User.all
```

```ruby
# возвратит первого пользователя
user = User.first
```

```ruby
# возвратит первого пользователя с именем David
david = User.find_by_name('David')
```

```ruby
# найдет всех пользователей с именем David, которые Code Artists, и сортирует их по created_at в обратном хронологическом порядке
users = User.where(name: 'David', occupation: 'Code Artist').order('created_at DESC')
```

Подробно о запросах в моделях Active Record можно узнать в руководстве [Интерфейс запросов Active Record](/active-record-query-interface).

### Обновление

Как только объект Active Record будет получен, его атрибуты могут быть изменены, и он может быть сохранен в базу данных.

```ruby
user = User.find_by_name('David')
user.name = 'Dave'
user.save
```

Сокращенным вариантом для этого является использование хэша с атрибутами, связанными с желаемыми значениями, таким образом:

```ruby
user = User.find_by_name('David')
user.update(name: 'Dave')
```

Это наиболее полезно, когда необходимо обновить несколько атрибутов за раз. Если, с другой стороны, необходимо обновить несколько записей за раз, полезен метод класса `update_all`:

```ruby
User.update_all "max_login_attempts = 3, must_change_password = 'true'"
```

### Удаление

Более того, после получения, объект Active Record может быть уничтожен, что уберет его из базы данных.

```ruby
user = User.find_by_name('David')
user.destroy
```

Валидации
---------

Active Record позволяет проверять состояние модели до того, как она будет записана в базу данных. Имеется несколько методов, которые могут быть использованы для проверки ваших моделей и валидации, что значение атрибута не пустое, уникальное (не существующее в базе данных), отвечает определенному формату, и многие другие.

Валидация - это очень важный вопрос, который нужно рассмотреть при сохранении в базу данных, поэтому методы `create`, `save` и `update` учитывают ее при запуске: они возвращают `false`, когда валидация проваливается, и фактически они не выполняют каких-либо операций с базой данных. Каждый из этих методов имеет пару с восклицательным знаком (`create!`, `save!` и `update!`), которые строже в том, что они вызывают исключение `ActiveRecord::RecordInvalid` если валидация провалится. Краткий пример:

```ruby
class User < ActiveRecord::Base
  validates :name, presence: true
end

User.create  # => false
User.create! # => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
```

Подробнее о валидациях можно прочитать в [руководстве по валидациям Active Record](/active-record-validations).

Колбэки
-------

Колбэки Active Record разрешают присоединить код к определенным событиям в жизненном цикле ваших моделей. Это позволяет добавить поведение модели, прозрачно запустив код, когда эти события произойдут, например, когда вы создадите новую запись, обновите его, удалите его и так далее. Подробнее о колбэках можно прочитать в [руководстве по колбэкам Active Record](/active-record-callbacks).

Миграции
--------

Rails представляет DSL для управления схемой базы данных, называемый миграциями. Миграции хранятся в файлах, запускаемых для любой базы данных, которую поддерживает Active Record, с использованием `rake`. Вот миграция, создающая таблицу:

```ruby
class CreatePublications < ActiveRecord::Migration
  def change
    create_table :publications do |t|
      t.string :title
      t.text :description
      t.references :publication_type
      t.integer :publisher_id
      t.string :publisher_type
      t.boolean :single_issue

      t.timestamps
    end
    add_index :publications, :publication_type_id
  end
end
```

Rails отслеживает, какие файлы переданы в базу данных, и представляет особенность отката. Чтобы фактически создать таблицу, нужно запустить `rake db:migrate`, а чтобы ее откатить `rake db:rollback`.

Отметьте, что вышеприведенный код не зависит от базы данных: он выполнится в MySQL, postgresql, Oracle и иных. Подробнее о миграциях можно прочитать в [руководстве по миграциям Active Record](/rails-database-migrations)
