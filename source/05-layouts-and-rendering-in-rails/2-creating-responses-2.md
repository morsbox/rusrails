# Создание откликов (часть вторая)

[>>> Первая часть.](/layouts-and-rendering-in-rails/creating-responses-1)

### Использование `redirect_to`

Другой способ управлять возвратом отклика на запрос HTTP - с помощью `redirect_to`. Как вы видели, `render` говорит Rails, какую вьюху (или иной ресурс) использовать в создании ответа. Метод `redirect_to` делает нечто полностью отличное: он говорит браузеру послать новый запрос по другому URL. Например, можно перенаправить из того места, где сейчас выполняется код, в индекс фотографий вашего приложения, с помощью этого вызова:

```ruby
redirect_to photos_url
```

`redirect_to` можно использовать с любыми аргументами, которые могут использоваться с `link_to` или `url_for`. Также имеется специальное перенаправление, посылающее пользователя обратно на страницу, с которой он пришел:

```ruby
redirect_to :back
```

#### Получение различного кода статуса перенаправления

Rails использует код статуса HTTP 302, временное перенаправление, при вызыве `redirect_to`. Если хотите использовать иной код статуса, возможно 301, постоянное перенаправление, можете использовать опцию `:status`:

```ruby
redirect_to photos_path, :status => 301
```

Подобно опции `:status` для `render`, `:status` для `redirect_to` принимает и числовые, и символьные обозначения заголовка.

#### Различие между `render` и `redirect_to`

Иногда неопытные разработчики думают о `redirect_to` как о разновидности команды `goto`, перемещающую выполнение из одного места в другое в вашем коде Rails. Это _не_ правильно. Ваш код останавливается и ждет нового запроса от браузера. Просто получается так, что вы говорите браузеру, какой запрос он должен сделать следующим, возвращая код статуса HTTP 302.

Рассмотрим эти экшны, чтобы увидеть разницу:

```ruby
def index
  @books = Book.all
end

def show
  @book = Book.find_by_id(params[:id])
  if @book.nil?
    render :action => "index"
  end
end
```

С кодом в такой форме, вероятно, будет проблема, если переменная `@book` равна `nil`. Помните, render :action` не запускает какой-либо код в указанном экшне, и таким образом ничего не будет присвоено переменной `@books`, которую возможно требует вьюха `index`. Способ исправить это - использовать перенаправление вместо рендера:

```ruby
def index
  @books = Book.all
end

def show
  @book = Book.find_by_id(params[:id])
  if @book.nil?
    redirect_to :action => :index
  end
end
```

С таким кодом браузер сделает новый запрос для индексной страницы, код в методе `index` запустится, и все будет хорошо.

Единственный недостаток этого кода в том, что он требует круговорот через браузер: браузер запрашивает экшн show с помощью `/books/1`, и контроллер обнаруживает, что книг нет, поэтому отсылает отклик-перенаправление 301 браузеру, сообщающий перейти на `/books/`, браузер выполняет и посылает новый запрос контроллеру, теперь запрашивая экшн `index`, затем контроллер получает все книги в базе данных и рендерит шаблон index, отсылает его обратно браузеру, который затем показывает его на экране.

Пока это небольшое приложение, такое состояние не может быть проблемой, но иногда стоит подумать, если время отклика важно. Можем продемонстрировать один из способов управления этим с помощью хитрого примера:

```ruby
def index
  @books = Book.all
end

def show
  @book = Book.find_by_id(params[:id])
  if @book.nil?
    @books = Book.all
    render "index", :alert => "Your book was not found!"
  end
end
```

Это обнаружит, что нет книг с определенным ID, заполнит переменную экземпляра `@books` всеми книгами в модели, и затем напрямую отрендерит шаблон `index.html.erb`, возвратив его браузеру с предупреждающим сообщением в flash, сообщающим пользователю, что произошло.

### Использование `head` для создания отклика, содержащего только заголовок

Метод `head` существует, чтобы позволить возвращать отклики браузеру, содержащие только заголовки. Он представляет более явную альтернативу вызова `render :nothing`. Метод `head` принимает один параметр, который интерпретируется как хэш имен заголовков и значений. Например, можете возвратить только заголовок ошибки:

```ruby
head :bad_request
```

Это создаст следующий заголовок:

```bash
HTTP/1.1 400 Bad Request
Connection: close
Date: Sun, 24 Jan 2010 12:15:53 GMT
Transfer-Encoding: chunked
Content-Type: text/html; charset=utf-8
X-Runtime: 0.013483
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
```

Или можете использовать другие заголовки HTTP для передачи другой информации:

```ruby
head :created, :location => photo_path(@photo)
```

Что создаст:

```bash
HTTP/1.1 201 Created
Connection: close
Date: Sun, 24 Jan 2010 12:16:44 GMT
Transfer-Encoding: chunked
Location: /photos/1
Content-Type: text/html; charset=utf-8
X-Runtime: 0.083496
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
```
