# Юнит-тестирование ваших моделей

В Rails юнит-тесты это то, что вы пишете, чтобы протестировать свои модели.

Для этого руководства мы будем использовать _скаффолдинг_ Rails. Он создает модель, миграцию, контроллер и вьюхи для нового ресурса в одной операции. Он также создает полный набор для тестирования, следуя лучшей практике Rails. Мы будем использовать примеры из этого созданного кода и будем добавлять к нему дополнительные примеры по необходимости.

NOTE: Чтобы узнать больше о _скаффолдинге_ Rails, обратитесь к [Rails для начинающих](/getting-started-with-rails)

При использовании `rails generate scaffold` для ресурса, среди прочего, создается незаконченный тест в папке `test/unit`:

```bash
$ rails generate scaffold post title:string body:text
...
create  app/models/post.rb
create  test/unit/post_test.rb
create  test/fixtures/posts.yml
...
```

Незаконченный тест по умолчанию в `test/unit/post_test.rb` выглядит так:

```ruby
require 'test_helper'

class PostTest < ActiveSupport::TestCase
  # Replace this with your real tests.
  test "the truth" do
    assert true
  end
end
```

Построчное изучение этого файла поможет вам ориентироваться в коде тестирования и терминологии Rails.

```ruby
require 'test_helper'
```

Как вы уже знаете, `test_helper.rb` определяет конфигурацию по умолчанию для запуска наших тестов. Эта строка включается во все тесты, таким образом все методы, добавленные в этот файл, доступны всем вашим тестам.

```ruby
class PostTest < ActiveSupport::TestCase
```

Класс `PostTest` определяет _тестовый случай (test case)_, поскольку он унаследован от `ActiveSupport::TestCase`. Поэтому `PostTest` имеет все методы, доступные в `ActiveSupport::TestCase`. Об этих методах вы узнаете немного позже.

Любой метод, определенный в тестовом случае `Test::Unit`, начинающийся с `test` (чувствительно к регистру), просто вызывает тест. Таким образом, `test_password`, `test_valid_password` и `testValidPassword` это правильные имена тестов, и запустятся автоматически при запуске тестового случая.

Rails добавляет метод `test`, который принимает имя теста и блок. Он создает обычный тест `Test::Unit` с именем метода, начинающегося с `test_`, поэтому:

```ruby
test "the truth" do
  assert true
end
```

Работает так же, как если бы написали:

```ruby
def test_the_truth
  assert true
end
```

Только макрос `test` делает имена тестов более читаемыми. Хотя можете использовать и обычные определения метода.

NOTE: Имя метода создается, заменяя пробелы на подчеркивания. Хотя результат не должен быть валидным идентификатором Ruby, имя может содержать знаки пунктуации и т.д. Это связано с тем, что в Ruby технически любая строка может быть именем метода. Необычность заключается в вызовах `define_method` и `send`, но формально ограничений нет.

```ruby
assert true
```

Эта строка кода называется _оператор контроля_. Оператор контроля это строка кода, которая вычисляет объект (или выражение) для ожидаемых результатов. Например, оператор контроля может проверить:

* является ли это значение = тому значению?
* является ли этот объект nil?
* вызывает ли эта строка кода исключение?
* является ли пароль пользователя больше, чем 5 символов?

Каждый тест содержит один или более операторов контроля. Только когда все операторы контроля успешны, тест проходит.

### Подготовка вашего приложения для тестирования

До того, как вы сможете запустить свои тесты, следует убедиться, что структура тестовой базы данных соответствует текущей. Для этого следует использовать такую команду rake:

```bash
$ rake db:migrate
...
$ rake db:test:load
```

Вышеупомянутая `rake db:migrate` запускает любые незагруженные миграции в среде _development_ и обновляет `db/schema.rb`. `rake db:test:load` пересоздает тестовую базу данных из текущего db/schema.rb. В следующий раз можете сначала запускать `db:test:prepare`, так как она сначала проверяет незагруженные миграции и надлежаще предупреждает вас.

NOTE: `db:test:prepare` провалится, если отсутствует db/schema.rb.

#### Задачи Rake для подготовки вашего приложения для тестирования

| Задачи                         | Описание                                                             |
| ------------------------------ | -------------------------------------------------------------------- |
| `rake db:test:clone`           | Пересоздает тестовую базу данных из схемы базы данных текущей среды |
| `rake db:test:clone_structure` | Пересоздает тестовую базу данных из структуры development            |
| `rake db:test:load`            | Пересоздает тестовую базу данных из текущего `schema.rb`             |
| `rake db:test:prepare`         | Проверяет незагруженные миграции и загружает тестовую схему          |
| `rake db:test:purge`           | Очищает тестовую базу данных.                                        |

TIP: Все эти команды rake и их описание можно увидеть, запустив `rake --tasks --describe`

### Запуск тестов

Запуск теста так же прост, как вызов файла, содержащего тестовый случай, с помощью Ruby:

```bash
$ ruby -Itest test/unit/post_test.rb

Loaded suite unit/post_test
Started
.
Finished in 0.023513 seconds.

1 tests, 1 assertions, 0 failures, 0 errors
```

Это запустит все тестовые методы в тестовом случае. Отметьте, что `test_helper.rb` находится в директории `test`, поэтому она должна быть добавлена в путь загрузки с использованием переключателя `-I`.

Также можете запустить определенный тестовый метод из тестового случая, используя переключатель `-n` с `именем тестового метода`.

```bash
$ ruby -Itest test/unit/post_test.rb -n test_the_truth

Loaded suite unit/post_test
Started
.
Finished in 0.023513 seconds.

1 tests, 1 assertions, 0 failures, 0 errors
```

Точка `.` обозначает прошедший тест. Когда тест проваливается, вы увидите `F`; когда тест вызывает ошибку, вы увидите `E` в этом месте. Последняя строка результата это итоги.

Чтобы увидеть, как сообщается при провале, давайте добавим проваливающийся тест в тестовом случае `post_test.rb`.

```ruby
test "should not save post without title" do
  post = Post.new
  assert !post.save
end
```

Давайте запустим только что добавленный тест.

```bash
$ ruby unit/post_test.rb -n test_should_not_save_post_without_title
Loaded suite -e
Started
F
Finished in 0.102072 seconds.

  1) Failure:
test_should_not_save_post_without_title(PostTest) [/test/unit/post_test.rb:6]:
<false> is not true.

1 tests, 1 assertions, 1 failures, 0 errors
```

В результате `F` обозначает провал. Можете увидеть соответствующую трассировку под `1)` вместе с именем провалившегося теста. Следующие несколько строк содержат трассировку стека, затем сообщение, где упомянуто фактическое значение и ожидаемое оператором контроля значение. Сообщение оператора контроля об ошибке предоставляет достаточно информации, чтобы помочь выявить ошибку. Чтобы сделать сообщение о провале оператора контроля более читаемым, каждый оператор контроля предоставляет опциональный параметр сообщения, как показано тут:

```ruby
test "should not save post without title" do
  post = Post.new
  assert !post.save, "Saved the post without a title"
end
```

Запуск этого теста покажет более дружелюбное контрольное сообщение:

```bash
  1) Failure:
test_should_not_save_post_without_title(PostTest) [/test/unit/post_test.rb:6]:
Saved the post without a title.
<false> is not true.
```

Теперь, чтобы этот тест прошел, можно добавить валидацию на уровне модели для поля _title_.

```ruby
class Post < ActiveRecord::Base
  validates :title, :presence => true
end
```

Теперь тест пройдет. Давайте убедимся в этом, запустив его снова:

```bash
$ ruby unit/post_test.rb -n test_should_not_save_post_without_title
Loaded suite unit/post_test
Started
.
Finished in 0.193608 seconds.

1 tests, 1 assertions, 0 failures, 0 errors
```

Теперь вы увидели, что мы сначала написали тест, который не прошел для желаемой функциональности, затем мы написали некоторый код, добавляющий функциональность, и наконец мы убедились, что наш тест прошел. Этот подход к разработке программного обеспечения упоминается как _Разработка через тестирование, Test-Driven Development_ (TDD).

TIP: Многие разработчики на Rails практикуют _разработку через тестирование_ (TDD). Это отличный способ создать набор тестов, который использует каждую часть вашего приложения. TDD выходит за рамки этого руководства, если хотите им заниматься, можете начать с [15 TDD steps to create a Rails application](http://andrzejonsoftware.blogspot.com/2007/05/15-tdd-steps-to-create-rails.html).

Чтобы увидеть, как сообщается об ошибке, вот тест, содержащий ошибку:

```ruby
test "should report error" do
  # some_undefined_variable is not defined elsewhere in the test case
  some_undefined_variable
  assert true
end
```

Теперь вы увидите чуть больше результата в консоли от запуска тестов:

```bash
$ ruby unit/post_test.rb -n test_should_report_error
Loaded suite -e
Started
E
Finished in 0.082603 seconds.

  1) Error:
test_should_report_error(PostTest):
NameError: undefined local variable or method `some_undefined_variable' for #<PostTest:0x249d354>
    /test/unit/post_test.rb:6:in `test_should_report_error'

1 tests, 0 assertions, 0 failures, 1 errors
```

Отметьте 'E' в результате. Она отмечает тест с ошибкой.

NOTE: Запуск каждого тестового метода останавливается как только случается любая ошибка или провал оператора контроля, и набор тестов продолжается со следующего метода. Все тестовые методы запускаются в алфавитном порядке.

### Что включить в ваши юнит-тесты

В идеале хотелось бы включить тест для всего, что может возможно сломаться. Хорошая практика иметь как минимум один тест на каждую валидацию и как минимум один тест на каждый метод в модели.

### Доступные операторы контроля

К этому моменту вы уже увидели некоторые из имеющихся операторов контроля. Операторы контроля это рабочие лошадки тестирования. Они единственные, кто фактически выполняет проверки, чтобы убедиться, что все работает как задумано.

Имеется множество различных типов операторов контроля, которые вы можете использовать. Вот полный перечень операторов контроля, которые поставляются с `test/unit`, библиотекой тестирования, используемой Rails. Параметр `[msg]` это опциональное строковое сообщение, которое можно определить, чтобы сделать сообщение о провале вашего теста яснее. Он не обязательный.

| Оператор контроля                                                | Назначение                                                                       |
| ---------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| `assert( boolean, [msg] )`                                       | Обеспечивает, что объект/выражение равен true.                                   |
| `assert_equal( expected, actual, [msg] )`                        | Обеспечивает, что `expected == actual` равно true.                               |
| `assert_not_equal( expected, actual, [msg] )`                    | Обеспечивает, что `expected == actual` равно false.                              |
| `assert_same( expected, actual, [msg] )`                         | Обеспечивает, что `expected.equal?(actual)` равно true.                          |
| `assert_not_same( expected, actual, [msg] )`                     | Обеспечивает, что `expected.equal?(actual)` равно false.                         |
| `assert_nil( obj, [msg] )`                                       | Обеспечивает, что `obj.nil?` равно true.                                         |
| `assert_not_nil( obj, [msg] )`                                   | Обеспечивает, что `!obj.nil?` равно true.                                        |
| `assert_match( regexp, string, [msg] )`                          | Обеспечивает, что строка соответствует регулярному выражению.                    |
| `assert_no_match( regexp, string, [msg] )`                       | Обеспечивает, что строка не соответствует регулярному выражению.                 |
| `assert_in_delta( expecting, actual, delta, [msg] )`             | Обеспечивает, что числа `expecting` и `actual` в пределах `delta` друг от друга. |
| `assert_throws( symbol, [msg] ) { block }`                       | Обеспечивает, что данный блок возвращает symbol.                                 |
| `assert_raise( exception1, exception2, ... ) { block }`          | Обеспечивает, что данный блок вызывает одно из данных исключений.                |
| `assert_nothing_raised( exception1, exception2, ... ) { block }` | Обеспечивает, что данный блок не вызывает одно из данных исключений.             |
| `assert_instance_of( class, obj, [msg] )`                        | Обеспечивает, что `obj` типа `class`.                                            |
| `assert_kind_of( class, obj, [msg] )`                            | Обеспечивает, что `obj` является или наследуется от `class`.                     |
| `assert_respond_to( obj, symbol, [msg] )`                        | Обеспечивает, что `obj` имеет метод, названный `symbol`.                         |
| `assert_operator( obj1, operator, obj2, [msg] )`                 | Обеспечивает, что `obj1.operator(obj2)` равен true.                              |
| `assert_send( array, [msg] )`                                    | Обеспечивает, что запуск метода, расположенного в `array[1]` на объекте в `array[0]` с параметрами `array[2 и выше]` равен true. Этот метод странный, ага?|
| `flunk( [msg] )`                                                 | Обеспечивает провал. Это полезно для явной отметки незаконченных пока тестов.    |

В силу модульной природы фреймворка тестирования, возможно создать свои собственные операторы контроля. Фактически Rails так и делает. Он включает некоторые специализированные операторы контроля, чтобы сделать жизнь разработчика проще.

NOTE: Создание собственных операторов контроля это особый разговор, которого мы касаться не будем.

### Специфичные операторы контроля Rails

Rails добавляет некоторые свои операторы контроля в фреймворк `test/unit`:

NOTE: `assert_valid(record)` устарел. Пожалуйста, используйте вместо него `assert(record.valid?)`.

| Оператор контроля                                                                 | Назначение |
| --------------------------------------------------------------------------------- | ---------- |
| `assert_valid(record)`                                                            |Обеспечивает, что переданная запись валидна по стандартам Active Record, и возвращает сообщение об ошибке, если нет.|
| `assert_difference(expressions, difference = 1, message = nil) {...}`             |Тестирует числовую разницу между возвращаемым значением expression и результатом вычисления в данном блоке.|
| `assert_no_difference(expressions, message = nil, &amp;block)`                    |Обеспечивает, что числовой результат вычисления expression не изменяется до и после применения переданного в блоке.|
| `assert_recognizes(expected_options, path, extras={}, message=nil)`               |Обеспечивает, что роутинг данного path был правильно обработан, и что проанализированные опции (заданные в хэше expected_options) соответствуют path. По существу он утверждает, что Rails распознает маршрут, заданный в expected_options.|
| `assert_generates(expected_path, options, defaults={}, extras = {}, message=nil)` |Утверждает, что предоставленные options могут быть использованы для создания предоставленного пути. Это противоположность assert_recognizes. Параметр extras используется, чтобы сообщить запросу имена и значения дополнительных параметров запроса, которые могут быть в строке запроса. Параметр message позволяет определить свое сообщение об ошибке при провале оператора контроля.|
| `assert_response(type, message = nil)`                                            |Утверждает, что отклик идет с определенным кодом статуса. Можете определить `:success` для обозначения 200-299, `:redirect` для обозначения 300-399, `:missing` для обозначения 404, или `:error` для соответствия диапазону 500-599|
| `assert_redirected_to(options = {}, message=nil)`                                 |Утверждает, что опции перенаправления передаются в соответствии с вызовами перенаправления в последнем экшне. Это соответствие может быть частичным, так `assert_redirected_to(:controller => "weblog")` будет также соответствовать перенаправлению `redirect_to(:controller => "weblog", :action => "show")` и тому подобное.|
| `assert_template(expected = nil, message=nil)`                                    |Утверждает, что запрос был ренедерен с подходящим файлом шаблона.|

Вы увидите использование некоторых из этих операторов контроля в следующей части.
