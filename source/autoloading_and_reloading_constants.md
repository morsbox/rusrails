Автозагрузка и перезагрузка констант (режим Zeitwerk)
=====================================================

Это руководство документирует, как работает автозагрузка и перезагрузка в режиме `zeitwerk`.

После его прочтения, вы узнаете:

* О режимах автоматической загрузки
* Об соответствующей настройке Rails
* О структуре проекта
* Об автоматической загрузке, перезагрузке и нетерпеливой загрузке
* О наследовании с единой таблицей
* И еще кое-что

--------------------------------------------------------------------------------

Введение
--------

INFO. Это руководство документирует автоматическую загрузку в режиме `zeitwerk`, новинкой Rails 6. Если, вместо этого, вы хотите прочитать о режиме `classic`, смотрите [Автозагрузка и перезагрузка констант (режим Classic)](/autoloading_and_reloading_constants_classic_mode).

В обычных классах в программах на Ruby зависимости нужно загружать вручную. Например, следующий контроллер использует классы `ApplicationController` и `Post`, и обычно необходимо для них добавить вызовы `require`:

```ruby
# НЕ ДЕЛАЙТЕ ЭТОГО.
require 'application_controller'
require 'post'
# НЕ ДЕЛАЙТЕ ЭТОГО.

class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end
```

Но это не в случае приложений Rails, когда классы и модули приложения доступны везде:

```ruby
class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end
```

Характерные приложения Rails только используют вызовы `require` для загрузки вещей из директории `lib`, стандартной библиотеки Ruby, гемов Ruby, и так далее. То есть того, что не принадлежит путям автозагрузки, описанным ниже.

Включение режима Zeitwerk
-------------------------

Режим автозагрузки `zeitwerk` включен по умолчанию в приложениях Rails 6, запускаемых на CRuby:

```ruby
# config/application.rb
config.load_defaults "6.x" # enables zeitwerk mode in CRuby
```

В режиме `zeitwerk` Rails использует [Zeitwerk](https://github.com/fxn/zeitwerk) для автоматической загрузки, перезагрузки и ленивой загрузки. Rails создает и настраивает экземпляр Zeitwerk, управляющий проектом.

INFO. Сам Zeitwerk не нужно настраивать вручную в приложении Rails. Скорее, нужно настроить приложение с помощью портируемых конфигурационных пунктов, разъясненных в этом руководстве, а Rails передаст это в Zeitwerk за вас.

Структура проекта
-----------------

В приложении Rails имена файлов должны соответствовать константам, которые они определяют, а директории выступают как пространства имен.

Например, файл `app/helpers/users_helper.rb` должен определять `UsersHelper`, а файл `app/controllers/admin/payments_controller.rb` должен определять `Admin::PaymentsController`.

Rails настраивает Zeitwerk, чтобы преобразовывать имена файлов с помощью `String#camelize`. Например, он ожидает, что `app/controllers/users_controller.rb` определяет константу `UsersController`, так как

```ruby
"users_controller".camelize # => UsersController
```

Если нужно изменить любые из этих преобразований, например, добавить сокращение, взгляните на `config/initializers/inflections.rb`.

Подробности в [документации Zeitwerk](https://github.com/fxn/zeitwerk#file-structure).

Пути автоматической загрузки
----------------------------

Мы называем _путями автозагрузки_ список директорий приложения, содержимое которых должно быть автоматически загружено. Например, `app/models`. Эти директории представляют корневое пространство имен: `Object`.

INFO. Пути автоматической загрузки называются _корневыми директориями_ в документации Zeitwerk, но в этом руководстве мы будем называть их "путь автозагрузки".

В пределах пути автозагрузки, имена файлов должны соответствовать константам, которые они определяют, как документировано [тут](https://github.com/fxn/zeitwerk#file-structure).

По умолчанию, пути автозагрузки приложения состоят из всех поддиректорий `app`, существующих во время загрузки приложения — за исключением `assets`, `javascripts`, `views` — плюс пути автозагрузки engine-ов, от которых оно может зависеть.

К примеру, если `UsersHelper` реализован в `app/helpers/users_helper.rb`, этот модуль автоматически загружаемый, и вам не нужно писать вызов `require` для него:

```
$ bin/rails runner 'p UsersHelper'
UsersHelper
```

Пути автозагрузки автоматически подхватывают любые пользовательские директории в `app`. Например, если в вашем приложении есть `app/presenters`, или `app/services` и т.д., они будут добавлены в пути автозагрузки.

Массив путей автозагрузки может быть расширен с помощью изменения `config.autoload_paths` в `config/application.rb`, но в настоящее время это не рекомендуется.

WARNING. Пожалуйста, не изменяйте `ActiveSupport::Dependencies.autoload_paths`, публичный интерфейс для изменения путей автозагрузки — это `config.autoload_paths`.

$LOAD_PATH
----------

Пути автозагрузки добавляются по умолчанию в `$LOAD_PATH`. Однако, внутренне Zeitwerk использует абсолютные имена файлов, и ваше приложение не должно иметь вызовов `require` для автоматически загружаемых файлов, таким образом, эти директории фактически тут не нужны. Вы можете их выключить с помощью флажка:

```ruby
config.add_autoload_paths_to_load_path = false
```

Это может немного ускорить правильные вызовы `require`, Поскольку будет меньше поиска. Также, если ваше приложение использует [Bootsnap](https://github.com/Shopify/bootsnap), это спасает библиотеку от построения ненужных индексов, что экономит RAM, которая ему нужна.

Перезагрузка
------------

Rails автоматически перезагружает классы и модули, если файлы приложения изменяются.

Если точнее, когда запущен веб сервер, и файлы приложения изменились, Rails выгружает все автоматически загруженные константы непосредственно перед тем, как обрабатывать следующий запрос. Таким образом, классы или модули приложения, используемые в течение этого запроса, будут автоматически загружены, таким образом, будет взята их текущая реализация из файловой системы.

Перезагрузка может быть включена или отключена. Настройкой, контролирующей это поведение, является `config.cache_classes`, которая по умолчанию false в режиме `development` (перезагрузка включена), и true по умолчанию в режиме `production` (перезагрузка выключена).

Rails определяет, что файлы изменились, с помощью событийного монитора файлов (по умолчанию), или проходя по путям автозагрузки, в зависимости от `config.file_watcher`.

В консоли Rails нет активного наблюдателя файлов, вне зависимости от значения `config.cache_classes`. Это так, потому что обычно будет сбивать с толку, если код перезагрузится посреди консольной сессии, по аналогии, как мы хотим, чтобы отдельный запрос обслуживался постоянным, неизменным набором классов и модулей приложения.

Однако, можно принудительно перезагрузить, выполнив в консоли `reload!`:

```
$ bin/rails c
Loading development environment (Rails 6.0.0)
irb(main):001:0> User.object_id
=> 70136277390120
irb(main):002:0> reload!
Reloading...
=> true
irb(main):003:0> User.object_id
=> 70136284426020
```

как видите, объект класса, хранимый в константе `User`, отличается после перезагрузки.

### Перезагрузка и устаревшие объекты

Очень важно понимать, что в Ruby нет способа настоящей перезагрузки классов и методов в памяти, и это отражается везде, где она используется. Технически "выгрузка" класса `User` означает удаление константы `User` с помощью `Object.send(:remove_const, "User")`.

Следовательно, если вы храните объект перезагружаемого класса или модуля в месте, которое не перезагружается, это значение становится устаревшим.

Например, если инициализатор хранит и кэширует определенный объект класса

```ruby
# config/initializers/configure_payment_gateway.rb
# НЕ ДЕЛАЙТЕ ТАК.
$PAYMENT_GATEWAY = Rails.env.production? ? RealGateway : MockedGateway
# НЕ ДЕЛАЙТЕ ТАК.
```

и `MockedGateway` становится перезагруженным, `$PAYMENT_GATEWAY` все еще хранит объект класса `MockedGateway`, вычисленный, когда был запущен инициализатор. Перезагрузка не изменит объект класса, хранящегося в `$PAYMENT_GATEWAY`.

Подобным образом, в консоле Rails, если у вас есть экземпляр user и перезагрузка:

```
> user = User.new
> reload!
```

объект `user` является экземпляром устаревшего объекта класса. Ruby дает вам новый класс, если вы снова вычислите `User`, но не обновит класс, экземпляром которого является `user`.

Другим использованием этой особенности является создание подкласса перезагружаемого класса в месте, которое не перезагружается:

```ruby
# lib/vip_user.rb
class VipUser < User
end
```

если `User` перезагружается, то, так как `VipUser` нет, суперклассом `VipUser` является оригинальный устаревший объект класса.

Вывод: **не кэшируйте перезагружаемые классы или модули**.

Нетерпеливая загрузка
---------------------

В средах, подобных production, обычно лучше загрузить весь код приложения при запуске приложения. Нетерпеливая загрузка помещает все в память для немедленного обслуживания запросов, это также сочетается с механизмом [копирования при записи](https://ru.wikipedia.org/wiki/Копирование_при_записи).

Нетерпеливая загрузка контролируется флажком `config.eager_load`, который по умолчанию включен в режиме `production`.

Порядок, в котором файлы нетерпеливо загружаются, не определен.

Если определена константа `Zeitwerk`, Rails вызывает `Zeitwerk::Loader.eager_load_all`, независимо от режима автоматической загрузки приложения. Это обеспечивает, что зависимости, контролируемые Zeitwerk, будут нетерпеливо загружены.

Наследование с единой таблицей
------------------------------

Наследование с единой таблицей является особенностью, не очень сочетающейся с ленивой загрузкой. Причина в том, что его API должен быть способен подсчитать иерархию STI, чтобы работать корректно, в то время как ленивая загрузка откладывает загрузку классов, пока на них не сослались. Невозможно подсчитать то, на что еще не сослались.

В некотором смысле, приложениям нужно нетерпеливо загрузить иерархии STI, независимо от режима загрузки.

Конечно, если приложение нетерпеливо загружается при старте, это уже выполняется. Когда нет, на практике достаточно инициализировать типы, существующие в базе данных, что обычно достаточно в режимах разработки или тестирования. Одним из способов это сделать является помещение этого модуля в директорию `lib`:

```ruby
module StiPreload
  unless Rails.application.config.eager_load
    extend ActiveSupport::Concern

    included do
      cattr_accessor :preloaded, instance_accessor: false
    end

    class_methods do
      def descendants
        preload_sti unless preloaded
        super
      end

      # Инициализирует как константу все типы, существующие в базе данных. There might be more on
      # На диске может быть и больше, но на практике это не имеет значения, пока речь идет о STI API.
      #
      # Предполагаем, что store_full_sti_class является true, по умолчанию.
      def preload_sti
        types_in_db = \
          base_class.
            select(inheritance_column).
            distinct.
            pluck(inheritance_column).
            compact

        types_in_db.each do |type|
          logger.debug("Preloading STI type #{type}")
          type.constantize
        end

        self.preloaded = true
      end
    end
  end
end
```

и затем включите его в корневые классы STI вашего проекта:

```ruby
# app/models/shape.rb
require "sti_preload"

class Shape < ApplicationRecord
  include StiPreload # Только в корневом класса.
end

# app/models/polygon.rb
class Polygon < Shape
end

# app/models/triangle.rb
class Triangle < Polygon
end
```

Rails.autoloaders
-----------------

Экземпляры Zeitwerk, управляющие вашим приложением, доступны в

```ruby
Rails.autoloaders.main
Rails.autoloaders.once
```

Первый — основной. Последний — в основном для обратной совместимости, в случае, если у приложения есть что-то в `config.autoload_once_paths` (сейчас это не рекомендуется).

Можно проверить, что режим `zeitwerk` включен, с помощью

```ruby
Rails.autoloaders.zeitwerk_enabled?
```

Выключение
----------

Приложения могут загружать умолчания Rails 6 и все еще использовать классический автоматический загрузчик следующим образом:

```ruby
# config/application.rb
config.load_defaults "6.x"
config.autoloader = :classic
```

Это удобно при обновлении до Rails 6 на различных стадиях, но классический режим не рекомендуется для новых приложений.

Режим `zeitwerk` не доступен в версиях Rails до 6.0.
