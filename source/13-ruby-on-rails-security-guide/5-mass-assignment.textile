h1. Массовое назначение

-- _Без каких-либо защитных мер Model.new(params[:model]) позволит злоумышленникам установить значение любого столбца базы данных._

Возможность массового назначения может стать проблемой, так как она позволяет злоумышленнику задать любые атрибуты модели, манипулируя с хэшем, передаваемым в метод модели +new()+:

<ruby>
def signup
  params[:user] # => {:name => “ow3ned”, :admin => true}
  @user = User.new(params[:user])
end
</ruby>

Массовое назначение экономит вам много усилий, так как не нужно устанавливать каждое значение отдельно. Просто передайте хэш в метод new, или присвойте attributes= значение хэша, для присвоения атрибутам модели значений в хэше. Проблема в том, что это часто используется в сочетании с хэшем параметров (params), доступным в контроллере, которым может манипулировать злоумышленник. Например, он может так изменить URL:

<pre>
"name":http://www.example.com/user/signup?user[name]=ow3ned&user[admin]=1
</pre>

Это передаст следующие параметры в контроллер:

<ruby>
params[:user] # => {:name => “ow3ned”, :admin => true}
</ruby>

Таким образом, если вы создаете нового пользователя, используя массовое назначение, можно очень просто стать администратором.

Отметьте, что эта уязвимость не ограничена столбцами базы данных. Любой устанавливающий метод, кроме явно защищенных, доступен через метод +attributes=+.  Фактически эта уязвимость распространилась еще больше с появлением вложенного массового назначения (и вложенных объектных форм) в Rails 2.3<plus>. Объявление +accepts_nested_attributes_for+ предоставляет нам возможность расширения массового назначения на связи модели (+has_many+, +has_one+, +has_and_belongs_to_many+). Например:

<ruby>
  class Person < ActiveRecord::Base
    has_many :children

    accepts_nested_attributes_for :children
  end

  class Child < ActiveRecord::Base
    belongs_to :person
  end
</ruby>

В результате уязвимость расширяется за рамки простого присвоения столбцов, предоставляя злоумышленнику возможность создания совершенно новых записей в связанных таблицах (в нашем случае children).

h4. Контрмеры

Чтобы всего этого избежать, Rails предоставляет два метода класса Active Record для контроля доступа к вашим атрибутам. Метод +attr_protected+ принимает перечень атрибутов, к которым не будет доступа при массовом назначении. Например:

<ruby>
attr_protected :admin
</ruby>

+attr_protected+ также дополнительно принимает опцию роли, используя :as, которая позволяет определить несколько группировок массового назначения. Если роль не определена, то атрибуты будут добавлены к роли :default.

<ruby>
attr_protected :last_login, :as => :admin
</ruby>

Более предпочтительным способом, поскольку он следует принципу белого списка, является метод +attr_accessible+. Это точная противоположность +attr_protected+, поскольку _(highlight)он принимает перечень атрибутов, которые будут доступны_. Все другие атрибуты будут защищены. С этим способом вы не забудете защитить атрибуты при добавлении новых в процессе разработки. Вот пример:

<ruby>
attr_accessible :name
attr_accessible :name, :is_admin, :as => :admin
</ruby>

Если захотите установить защищенный атрибут, нужно назначить его отдельно:

<ruby>
params[:user] # => {:name => "ow3ned", :admin => true}
@user = User.new(params[:user])
@user.admin # => false # not mass-assigned
@user.admin = true
@user.admin # => true
</ruby>

При назначении атрибутов в Active Record при использовании +attributes=+ будет использована роль :default. Чтобы назначить атрибуты, используя различные роли, следует использовать +assign_attributes+, который принимает опциональный параметр :as. Если опция :as не предоставлена, то будет использована роль :default. Также можно пропустить проверку массового назначения используя опцию +:without_protection+. Вот пример:

<ruby>
@user = User.new

@user.assign_attributes({ :name => 'Josh', :is_admin => true })
@user.name # => Josh
@user.is_admin # => false

@user.assign_attributes({ :name => 'Josh', :is_admin => true }, :as => :admin)
@user.name # => Josh
@user.is_admin # => true

@user.assign_attributes({ :name => 'Josh', :is_admin => true }, :without_protection => true)
@user.name # => Josh
@user.is_admin # => true
</ruby>

подобным образом методы +new+, +create+, +create!+, +update_attributes+ и +update_attributes!+ учитывают проверку массового назначения и принимают либо опцию +:as+, либо опцию +:without_protection+. Например:

<ruby>
@user = User.new({ :name => 'Sebastian', :is_admin => true }, :as => :admin)
@user.name # => Sebastian
@user.is_admin # => true

@user = User.create({ :name => 'Sebastian', :is_admin => true }, :without_protection => true)
@user.name # => Sebastian
@user.is_admin # => true
</ruby>

Более параноидальной техникой защитить целый проект будет принуждение всех моделей иметь белые списки своих доступных атрибутов. Это достигается с помощью простого инициализатора:

<ruby>
config.active_record.whitelist_attributes = true
</ruby>

Это просто создаст пустой белый список атрибутов, доступных для массового назначения, во всех моделях вашего приложения. Как таковые, ваши модели будут нуждаться в явном белом списке доступных параметров, с использованием объявления +attr_accessible+ или +attr_protected+. Эту технику лучше всего применять при запуске нового проекта. Однако для существующего проекта с полным набором функциональных тестов может быть простым и относительно быстрым вставить этот инициализатор, запустить тесты и выставить каждый атрибут (с помощью +attr_accessible+ или +attr_protected+), как диктуют ваши проваленные тесты.
