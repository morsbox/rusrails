# Перенаправление и файлы

Другой класс уязвимостей в безопасности связан с использованием перенаправления и файлов в веб приложениях.

### Перенаправление

WARNING: _Перенаправление в веб приложении это недооцениваемый инструмент взломщика: на сайт-ловушку может направить пользователя не только злоумышленник, но и сам пользователь._

Всякий раз когда пользователь допускается к передаче (всего или части) URL для перенаправления, это является возможной уязвимостью. Наиболее банальной атакой может быть перенаправление пользователей на фальшивое веб приложение, которое выглядит и работает как настоящее. Эта так называемая фишинг атака работает через посланную не вызывающую подозрения ссылку в email для пользователей, вставленную в приложение ссылку с помощью XSS или ссылку, помещенную на внешнем сайте. Она не вызывает подозрений, так как ссылка начинается с URL к веб приложению, а URL к злонамеренному сайту скрыт в параметре перенаправления: http://www.example.com/site/redirect?to=www.attacker.com. Вот пример экшна legacy:

```ruby
def legacy
  redirect_to(params.update(:action=>'main'))
end
```

Он перенаправит пользователя на экшн main, если тот попытается получить доступ к экшну legacy. Намерением было сохранить параметры URL к экшну legacy и передать их экшну main. Однако это может быть использовано злоумышленником, если он включит ключ host в URL:

```
http://www.example.com/site/legacy?param1=xy&param2=23&host=www.attacker.com
```

Этот URL в конце вряд ли будет замечен и перенаправит пользователя на хост attacker.com. Простой контрмерой будет являться _включение только ожидаемых параметров в эхшн legacy_ (снова подход белого списка, в отличие от устранения нежелательных параметров). _И если вы перенаправляете на URL, сверьтесь с белым списком или регулярным выражением_.

#### Самодостаточный XSS

Другая перенаправляющая и самодостаточная XSS атака работает в Firefox и Opera с использованием протокола данных. Этот протокол отображает свое содержимое прямо в браузер и может быть чем угодно от HTML или JavaScript до простых изображений:

`data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K`

Этот пример является закодированным Base64 JavaScript, который отображает простое окно сообщения. В перенаправляющем URL злоумышленник может перенаправить на этот URL с помощью злонамеренного кода в нем. В качестве контрмеры _не позволяйте пользователю предоставлять (полностью или частично) URL, на который нужно перенаправить_.

### Загрузки файла

NOTE: _Убедитесь, что загрузки файлов не перезапишут важные файлы и обрабатывают медиа файлы асинхронно._

Многие веб приложения позволяют пользователям загружать файлы. _Имена файла, которые пользователи могут выбирать (частично), всегда должны быть фильтрованы_, так как злоумышленник может использовать злонамеренное имя файла для перезаписи любого файла на сервере. Если загруженные файлы храняться в /var/www/uploads, и пользователь введет имя файла такое как “../../../etc/passwd”, это сможет перезаписать важный файл. Конечно, интерпретатору Ruby будут требоваться необходимые разрешения, чтобы сделать это – еще одна причина запускать веб серверы, серверы базы данных и другие программы под наименее привилегированным пользователем Unix.

Когда фильтруете имена файлов, введенных пользователем, _не пытайтесь убрать злонамеренные части_. Подумайте о ситуации, когда веб приложение убирает все “../” в имени файла, и злоумышленник использует строку, такую как “....//”, результатом будет “../”. Лучше использовать подход белого списка, который _проверяет на валидность имя файла с помощью набора приемлемых символов_. Это противопоставляется подходу черного списка, который пытается убрать недопустимые символы. В случае невалидного имени файла отвергните его (или замените неприемлемые символы), но не убирайте их. Вот санитайзер имени файла из [плагина attachment_fu](http://github.com/technoweenie/attachment_fu/tree/master):

```ruby
def sanitize_filename(filename)
  filename.strip.tap do |name|
    # NOTE: File.basename doesn't work right with Windows paths on Unix
    # get only the filename, not the whole path
    name.sub! /\A.*(\\|\/)/, ''
    # Finally, replace all non alphanumeric, underscore
    # or periods with underscore
    name.gsub! /[^\w\.\-]/, '_'
  end
end
```

Значительный недостаток синхронной обработки загрузок файла (что плагин attachment_fu может сделать с изображениями), это его _уязвимость к DoS-атакам_. Злоумышленник может синхронно начать загрузки файла изображения с многих компьютеров, которые увеличат загрузку сервера и могут в конечном счете свалить или затормозить сервер.

Лучшее решение этого состоит в _асинхронной обработке медиа файлов_: сохраните медиафайл и расписание обработки запроса в базу данных. Второй процесс будет заниматься обработкой файла в фоновом режиме.

### Исполняемый код в загрузках файла

WARNING: _Исходный код в загруженных файлах может быть исполнен при помещении в определенные директории. Не помещайте загрузки файла в директорию Rails /public, если это домашняя директория Apache._

Популярный веб сервер Apache имеет опцию, называемую DocumentRoot. Это домашняя директория веб сайта, все в дереве этой директории будет обслуживаться веб сервером. Если там имеются файлы с определенным расширением имени, код в в них будет выполнен при запросе (может требоваться установка некоторых опций). Примерами этого являются файлы PHP и CGI. Теперь представьте ситуацию, когда злоумышленник загружает файл “file.cgi” с кодом, который будет запущен, когда кто-то скачивает файл.

_Если Apache DocumentRoot указывает на директорию Rails /public, не помещайте загрузки файлов в него_, храните файлы как минимум на один уровень ниже.

### Скачивания файла

NOTE: _Убедитесь, что пользователи не могут скачивать произвольные файлы._

Так же как вы фильтруете имена файла для загрузки, следует делать то же самое для скачивания. Метод send_file() посылает файлы от сервера на клиент. Если использовать имя файла, введенного пользователем, без фильтрации, может быть скачан любой файл:

```ruby
send_file('/var/www/uploads/' ` params[:filename])
```

Просто передайте имя файла такое, как “../../../etc/passwd”, чтобы загрузить информацию о доступе к серверу. Простым решением против этого является _проверка того, что запрашиваемый файл находится в ожидаемой директории_:

```ruby
basename = File.expand_path(File.join(File.dirname(__FILE__), '../../files'))
filename = File.expand_path(File.join(basename, @file.public_filename))
raise if basename !=
     File.expand_path(File.join(File.dirname(filename), '../../../'))
send_file filename, :disposition => 'inline'
```

Другой (дополнительный) подход заключается в хранении имен файлов в базе данных и именовании файлов на диске по id в базе данных. Это также хороший подход для избежания возможного кода в загруженных файлах, который может быть запущен. Плагин attachment_fu осуществляет это похожим образом.
