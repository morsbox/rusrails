# Нетерпеливая загрузка связей

Нетерпеливая загрузка - это механизм загрузки связанных записей объекта, возвращаемого `Model.find`, с использованием как можно меньшего количества запросов.

**Проблема N + 1 запроса**

Рассмотрим следующий код, который находит 10 клиентов и печатает их почтовые индексы:

```ruby
clients = Client.limit(10)

clients.each do |client|
  puts client.address.postcode
end
```

На первый взгляд выглядит хорошо. Но проблема лежит в в общем количестве выполненных запросов. Вышеупомянутый код выполняет 1 (чтобы найти 10 клиентов) + 10 (каждый на одного клиента для загрузки адреса) = итого **11** запросов.

**Решение проблемы N + 1 запроса**

Active Record позволяет усовершенствовано определить все связи, которые должны быть загружены. Это возможно с помощью определения метода `includes` на вызове `Model.find`. Посредством `includes`, Active Record обеспечивает то, что все определенные связи загружаются с использованием минимально возможного количества запросов.

Пересмотривая вышеупомянутую задачу, мы можем переписать `Client.limit(10)` для использование нетерпеливой загрузки адресов:

```ruby
clients = Client.includes(:address).limit(10)

clients.each do |client|
  puts client.address.postcode
end
```

Этот код выполнит всего **2** запроса, вместо **11** запросов из прошлого примера:

```sql
SELECT * FROM clients LIMIT 10
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
```

### Нетерпеливая загрузка нескольких связей

Active Record позволяет нетерпеливо загружать любое количество связей в одном вызове `Model.find` с использованием массива, хэша, или вложенного хэша массивов/хэшей, с помощью метода `includes`.

#### Массив нескольких связей

```ruby
Post.includes(:category, :comments)
```

Это загрузит все публикации и связанные категорию и комментарии для каждой публикации.

#### Вложенный хэш связей

```ruby
Category.includes(:posts => [{:comments => :guest}, :tags]).find(1)
```

Вышеприведенный код находит категории с id 1 и нетерпеливо загружает все публикации, связанные с найденной категорией. Кроме того, он также нетерпеливо загружает теги и комментарии каждой публикации. Гость, связанный с оставленным комментарием, также будет нетерпеливо загружен.

### Определение условий для нетерпеливой загрузки связей

Хотя Active Record и позволяет определить условия для нетерпеливой загрузки связей, как и в `joins`, рекомендуем использовать вместо этого "joins":/active-record-query-interface/joining-tables.

Однако, если вы сделаете так, то сможете использовать `where` как обычно.

```ruby
Post.includes(:comments).where("comments.visible" => true)
```

Это сгенерирует запрос с ограничением `LEFT OUTER JOIN`, в то время как метод `joins` сгенерировал бы его с использованием функции `INNER JOIN`.

```ruby
  SELECT "posts"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "posts"
    LEFT OUTER JOIN "comments" ON "comments"."post_id" = "posts"."id" WHERE (comments.visible = 1)
```

Если бы не было условия `where`, то сгенерировался бы обычный набор из двух запросов.

Если, в случае с этим запросом `includes`, не будет ни одного комментария ни для одной публикации, все публикации все равно будут загружены. При использовании `joins` (INNER JOIN), соединительные условия **должны** соответствовать, иначе ни одной записи не будет возвращено.
