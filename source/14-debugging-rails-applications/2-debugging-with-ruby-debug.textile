h1. Отладка с помощью ruby-debug

Когда ваш код ведет себя неожиданным образом, можете печатать в логи или консоль, чтобы выявить проблему. К сожалению, иногда бывает, что такой способ отслеживания ошибки не эффективен в поиске причины проблемы. Когда вы фактически нуждаетесь в путешествии вглубь исполняемого кода, отладчик - это ваш лучший напарник.

Отладчик также может помочь, если хотите изучить исходный код Rails, но не знаете с чего начать. Просто отладьте любой запрос к своему приложению и используйте это руководство для изучения, как идет движение от написанного вами кода глубже в код Rails.

h4. Установка

Отладчик, используемый Rails, +ruby-debug+, поставляется как гем. Чтобы установить его, просто запустите:

<shell>
$ sudo gem install ruby-debug
</shell>

TIP: Если вы используете Ruby 1.9, можно установить совместимую версию +ruby-debug+, запустив +sudo gem install ruby-debug19+

В случае, если вы хотите загрузить особую версию или получить исходный код, обратитесь к "странице проекта на rubyforge":http://rubyforge.org/projects/ruby-debug/.

В Rails есть встроенная поддержка ruby-debug, начиная с Rails 2.0. Внутри любого приложения на Rails можно вызывать отладчик, вызвав метод +debugger+.

Вот пример:

<ruby>
class PeopleController < ApplicationController
  def new
    debugger
    @person = Person.new
  end
end
</ruby>

Если видите сообщение в консоли или логах:

<shell>
***** Debugger requested, but was not available: Start server with --debugger to enable *****
</shell>

Убедитесь, что запустили свой веб сервер с опцией +--debugger+:

<shell>
$ rails server --debugger
=> Booting WEBrick
=> Rails 3.0.0 application starting on http://0.0.0.0:3000
=> Debugger enabled
...
</shell>

TIP: В режиме development можно динамически вызвать +require 'ruby-debug'+ вместо перезапуска сервера, если он был запущен без +--debugger+.

h4. Среда

Как только приложение вызывает метод +debugger+, отладчик будет запущен в среде отладчика в окне терминала, в котором запущен сервер приложения, и будет представлена строка ruby-debug +(rdb:n)+. _n_ это число нитей (thread). Строка также показывает следующую линию кода, которая ожидает выполнения.

Если был получен запрос от браузера, закладка браузера, содержащая запрос, будет висеть, пока отладчик не закончит, и трассировка не закончит обрабатывать весь запрос.

Например:

<shell>
@posts = Post.all
(rdb:7)
</shell>

Настало время изучить и покопаться в вашем приложении. Для начала хорошо бы попросить помощь у отладчика... поэтому напишите: +help+ (Неожиданно, правда?)

<shell>
(rdb:7) help
ruby-debug help v0.10.2
Type 'help <command-name>' for help on a specific command

Available commands:
backtrace  delete   enable  help    next  quit     show    trace
break      disable  eval    info    p     reload   source  undisplay
catch      display  exit    irb     pp    restart  step    up
condition  down     finish  list    ps    save     thread  var
continue   edit     frame   method  putl  set      tmate   where
</shell>

TIP: Чтобы просмотреть помощь для любой команды, используйте +help <имя команды>+ в активном режиме отладки. Например: _+help var+_

Следующая команда, которую мы изучим, одна из самых полезных: +list+. Также можно сокращать команды ruby-debug, предоставляя только достаточные буквы для отличения их от других команд, поэтому можно использовать +l+ для команды +list+.

Эта команда показывает, где вы сейчас в коде, печатая 10 линий с текущей линией в центре; текущая линия в этом случая шестая и помеченная +=>+.

<shell>
(rdb:7) list
[1, 10] in /PathToProject/posts_controller.rb
   1  class PostsController < ApplicationController
   2    # GET /posts
   3    # GET /posts.json
   4    def index
   5      debugger
=> 6      @posts = Post.all
   7
   8      respond_to do |format|
   9        format.html # index.html.erb
   10        format.json { render :json => @posts }
</shell>

Если повторите команду +list+, сейчас уже используем лишь +l+, будут выведены следующие 10 линий файла.

<shell>
(rdb:7) l
[11, 20] in /PathTo/project/app/controllers/posts_controller.rb
   11      end
   12    end
   13
   14    # GET /posts/1
   15    # GET /posts/1.json
   16    def show
   17      @post = Post.find(params[:id])
   18
   19      respond_to do |format|
   20        format.html # show.html.erb
</shell>

И так далее до конца текущего файла. Когда достигнут конец файла, команда +list+ запустится снова с начала файла и продолжится опять до конца, обрабатывая файл как цикличный буфер.

С другой стороны, чтобы увидеть предыдущие десять линий, следует написать +list-+ или +l-+.

<shell>
(rdb:7) l-
[1, 10] in /PathToProject/posts_controller.rb
   1  class PostsController < ApplicationController
   2    # GET /posts
   3    # GET /posts.json
   4    def index
   5      debugger
   6      @posts = Post.all
   7
   8      respond_to do |format|
   9        format.html # index.html.erb
   10        format.json { render :json => @posts }
</shell>

Таким образом можно перемещаться внутри файла, просматривая код до и после строки, в которую вы добавили +debugger+. Наконец, чтобы снова увидеть, где вы в коде сейчас, можно написать +list=+.

<shell>
(rdb:7) list=
[1, 10] in /PathToProject/posts_controller.rb
   1  class PostsController < ApplicationController
   2    # GET /posts
   3    # GET /posts.json
   4    def index
   5      debugger
=> 6      @posts = Post.all
   7
   8      respond_to do |format|
   9        format.html # index.html.erb
   10        format.json { render :json => @posts }
</shell>

h4. Контекст

Когда начинаете отладку своего приложения, вы будете помещены в различные контексты, так как проходите через различные части стека.

ruby-debug создает контекст, когда достигается точка останова или событие. У контекста есть информация о приостановленной программе, которая позволяет отладчику просматривать кадр стека, значения переменных с точки зрения отлаживаемой программы, и в нем содержится информация о месте, в котором отлаживаемая программа остановилась.

В любое время можете вызвать команду +backtrace+ (или ее псевдоним +where+), чтобы напечатать трассировку приложения. Это полезно для того, чтобы знать, где вы есть. Если вы когда-нибудь задумывались, как вы получили что-то в коде, то +backtrace+ предоставит ответ.

<shell>
(rdb:5) where
    #0 PostsController.index
       at line /PathTo/project/app/controllers/posts_controller.rb:6
    #1 Kernel.send
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/base.rb:1175
    #2 ActionController::Base.perform_action_without_filters
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/base.rb:1175
    #3 ActionController::Filters::InstanceMethods.call_filters(chain#ActionController::Fil...,...)
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/filters.rb:617
...
</shell>

Можете перейти, куда хотите в этой трассировке (это изменит контекст) с использованием команды +frame _n_+, где _n_ это определенный номер кадра.

<shell>
(rdb:5) frame 2
#2 ActionController::Base.perform_action_without_filters
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/base.rb:1175
</shell>

Доступные переменные те же самые, как если бы вы запускали код строка за строкой. В конце концов, это то, что отлаживается.

Перемещение по кадру стека: можете использовать команды +up [n]+ (скоращенно +u+) и +down [n]+ для того, чтобы изменить контекст на _n_ кадров вверх или вниз по стеку соответственно. _n_ по умолчанию равно одному. Up в этом случае перейдет к кадрам стека с большим номером, а down к кадрам с меньшим номером.

h4. Нити (threads)

Отладчик может просматривать, останавливать, возобновлять и переключаться между запущенными нитями с использованием команды +thread+ (или сокращенно +th+). У этой команды есть несколько опций:

* +thread+ показывает текущую нить
* +thread list+ используется для отображения всех нитей и их статусов. Символ плюс + и число показывают текущую нить выполнения.
* +thread stop _n_+ останавливает нить _n_.
* +thread resume _n_+ возобновляет нить _n_.
* +thread switch _n_+ переключает контекст текущей нити на _n_.

Эта команда очень полезна, в частности когда вы отлаживаете параллельные нити и нужно убедиться, что в коде нет состояния гонки.

h4. Просмотр переменных

Любое выражение может быть вычислено в текущем контексте. Чтобы вычислить выражение, просто напечатайте его!

Этот пример покажет, как можно напечатать instance_variables, определенные в текущем контексте:

<shell>
@posts = Post.all
(rdb:11) instance_variables
["@_response", "@action_name", "@url", "@_session", "@_cookies", "@performed_render", "@_flash", "@template", 
  "@_params", "@before_filter_chain_aborted", "@request_origin", "@_headers", "@performed_redirect", "@_request"]
</shell>

Как вы уже поняли, отображены все переменные, к которым есть доступ из контроллера. Этот перечень динамически обновляется по мере выполнения кода. Например, запустим следующую строку, используя +next+ (мы рассмотрим эту команду чуть позднее в этом руководстве).

<shell>
(rdb:11) next
Processing PostsController#index (for 127.0.0.1 at 2008-09-04 19:51:34) [GET]
  Session ID: BAh7BiIKZmxhc2hJQzonQWN0aW9uQ29udHJvbGxlcjo6Rmxhc2g6OkZsYXNoSGFzaHsABjoKQHVzZWR7AA==--b16e91b992453a8cc201694d660147bba8b0fd0e
  Parameters: {"action"=>"index", "controller"=>"posts"}
/PathToProject/posts_controller.rb:8
respond_to do |format|
</shell>

И затем снова спросим instance_variables:

<shell>
(rdb:11) instance_variables.include? "@posts"
true
</shell>

Теперь +@posts+ включена в переменные экземпляра, поскольку определяющая ее строка была выполнена.

TIP: Также можно шагнуть в режим *irb* с командой +irb+ (конечно!). Таким образом, сессия irb будет запущена в контексте, который ее вызвал. Но предупреждаем: это эксперементальная особенность.

Метод +var+ это более удобный способ показать переменные и их значения:

<shell>
var
(rdb:1) v[ar] const <object>            показывает константы объекта
(rdb:1) v[ar] g[lobal]                  показывает глобальные переменные
(rdb:1) v[ar] i[nstance] <object>       показывает переменные экземпляра объекта
(rdb:1) v[ar] l[ocal]                   показывает локальные переменные
</shell>

Это отличный способ просмотреть значения переменных текущего контекста. Например:

<shell>
(rdb:9) var local
  __dbg_verbose_save => false
</shell>

Также можно просмотреть метод объекта следующим образом:

<shell>
(rdb:9) var instance Post.new
@attributes = {"updated_at"=>nil, "body"=>nil, "title"=>nil, "published"=>nil, "created_at"...
@attributes_cache = {}
@new_record = true
</shell>

TIP: Команды +p+ (print) и +pp+ (pretty print) могут использоваться для вычисления выражений Ruby и отображения значения переменных в консоли.

Можете также использовать +display+ для запуска просмотра переменных. Это хороший способ трассировки значений переменной на протяжении выполнения.

<shell>
(rdb:1) display @recent_comments
1: @recent_comments =
</shell>

Переменные в отображаемом перечне будут печататься с их значениями после помещения в стек. Чтобы остановить отображение переменной, используйте +undisplay _n_+, где _n_ это номер переменной (1 в последнем примере).

h4. Шаг за шагом

Теперь вы знаете, где находитесь в запущенной трассировке, и способны напечатать доступные переменные. Давайте продолжим и ознакомимся с выполнением приложения.

Используйте +step+ (сокращенно +s+) для продолжения запуска вашей программы до следующей логической точки останова и возврата контроля ruby-debug.

TIP: Также можно использовать <tt>step<plus> n</tt> и <tt>step- n</tt> для движения вперед или назад на +n+ шагов соответственно.

Также можете использовать _next_, которая похожа на step, но вызовы функции или метода, выполняемые в строке кода, выполняются без остановки. Как и со step, можно использовать знак плюса для перемещения на _n_ шагов.

Разница между +next+ и +step+ в том, что +step+ останавливается на следующей линии выполняемого кода, делая лишь один шаг, в то время как +next+ перемещает на следующую строку без входа внутрь методов.

Например, рассмотрим этот блок кода с включенным выражением +debugger+:

<ruby>
class Author < ActiveRecord::Base
  has_one :editorial
  has_many :comments

  def find_recent_comments(limit = 10)
    debugger
    @recent_comments ||= comments.where("created_at > ?", 1.week.ago).limit(limit)
  end
end
</ruby>

TIP: Можете использовать ruby-debug при использовании +rails console+. Просто не забудьте вызвать +require "ruby-debug"+ перед вызовом метода +debugger+.

<shell>
$ rails console
Loading development environment (Rails 3.1.0)
>> require "ruby-debug"
=> []
>> author = Author.first
=> #<Author id: 1, first_name: "Bob", last_name: "Smith", created_at: "2008-07-31 12:46:10", updated_at: "2008-07-31 12:46:10">
>> author.find_recent_comments
/PathTo/project/app/models/author.rb:11
)
</shell>

С остановленным кодом, давайте оглянемся:

<shell>
(rdb:1) list
[2, 9] in /PathTo/project/app/models/author.rb
   2    has_one :editorial
   3    has_many :comments
   4
   5    def find_recent_comments(limit = 10)
   6      debugger
=> 7      @recent_comments ||= comments.where("created_at > ?", 1.week.ago).limit(limit)
   8    end
   9  end
</shell>

Вы в конце линии, но была ли эта линия выполнена? Можете просмотреть переменные экземпляра.

<shell>
(rdb:1) var instance
@attributes = {"updated_at"=>"2008-07-31 12:46:10", "id"=>"1", "first_name"=>"Bob", "las...
@attributes_cache = {}
</shell>

+@recent_comments+ пока еще не определена, поэтому ясно, что эта линия еще не выполнялась. Используем команду +next+ для движения дальше по коду:

<shell>
(rdb:1) next
/PathTo/project/app/models/author.rb:12
@recent_comments
(rdb:1) var instance
@attributes = {"updated_at"=>"2008-07-31 12:46:10", "id"=>"1", "first_name"=>"Bob", "las...
@attributes_cache = {}
@comments = []
@recent_comments = []
</shell>

Теперь мы видим, что связь +@comments+ была загружена и @recent_comments определена, поскольку линия была выполнена.

Если хотите войти глубже в трассировку стека, можете переместиться на один шаг +step+, через ваши вызывающие методы и в код Rails. Это лучший способ поиска багов в вашем коде, а возможно и в Ruby or Rails.

h4. Точки останова

Точка останова останавливает ваше приложение, когда достигается определенная точка в программе. В этой линии вызывается оболочка отладчика.

Можете добавлять точки останова динамически с помощью команды +break+ (или просто +b+). Имеются 3 возможных способа ручного добавления точек останова:

* +break line+: устанавливает точку останова в линии _line_ в текущем файле исходника.
* +break file:line [if expression]+: устанавливает точку останова в линии номер _line_ в файле _file_. Если задано условие _expression_, оно должно быть вычислено и равняться _true_, чтобы запустить отладчик.
* +break class(.|#)method [if expression]+: устанавливает точку останова в методе _method_ (. и # для метода класса и экземпляра соответственно), определенного в классе _class_. _expression_ работает так же, как и с file:line.

<shell>
(rdb:5) break 10
Breakpoint 1 file /PathTo/project/vendor/rails/actionpack/lib/action_controller/filters.rb, line 10
</shell>

Используйте +info breakpoints _n_+ или +info break _n_+ для отображения перечня точек останова. Если укажете номер, отобразится только эта точка останова. В противном случае отобразятся все точки останова.

<shell>
(rdb:5) info breakpoints
Num Enb What
  1 y   at filters.rb:10
</shell>

Чтобы удалить точки останова: используйте команду +delete _n_+ для устранения точки останова номер _n_. Если номер не указан, удалятся все точки останова, которые в данный момент активны..

<shell>
(rdb:5) delete 1
(rdb:5) info breakpoints
No breakpoints.
</shell>

Также можно включить или отключить точки останова:

* +enable breakpoints+: позволяет перечню _breakpoints_ или всем им, если перечень не определен, останавливать вашу программу. Это состояние по умолчанию для создаваемых точек останова.
* +disable breakpoints+: _breakpoints_ не будут влиять на вашу программу.

h4. Вылов исключений

Команда +catch exception-name+ (или просто +cat exception-name+) может использоваться для перехвата исключения типа _exception-name_, когда в противном случае был бы вызван обработчик для него.

Чтобы просмотреть все активные точки перехвата, используйте +catch+.

h4. Возобновление исполнения

Есть два способа возобновления выполнения приложения, которое было остановлено отладчиком:

* +continue+ [line-specification] (или +c+): возобновляет выполнение программы с адреса, где ваш скрипт был последний раз остановлен; любые точки останова, установленные на этом адресе будут пропущены. Дополнительный аргумент line-specification позволяет вам определить число линий для установки одноразовой точки останова, которая удаляется после того, как эта точка будет достигнута.
* +finish+ [frame-number] (или +fin+): выполняет, пока не возвратится выделенный кадр стека. Если номер кадра не задан, приложение будет запущено пока не возвратиться текущий выделенный кадр. Текущий выделенный кадр начинается от самых последних, или с 0, если позиционирование кадров (т.е. up, down или frame) не было выполнено. Если задан номер кадра, будет выполняться, пока не вернется указанный кадр.

h4. Редактирование

Две команды позволяют открыть код из отладчика в редакторе:

* +edit [file:line]+: редактирует файл _file_, используя редактор, определенный переменной среды EDITOR. Определенная линия _line_ также может быть задана.
* +tmate _n_+ (сокращенно +tm+): открывает текущий файл в TextMate. Она использует n-ный кадр, если задан _n_.

h4. Выход

Чтобы выйти из отладчика, используйте команду +quit+ (сокращенно +q+), или ее псевдоним +exit+.

Простой выход пытается прекратить все нити в результате. Поэтому ваш сервер будет остановлен и нужно будет стартовать его снова.

h4. Настройки

Есть несколько настроек, которые могут быть сконфигурированы в ruby-debug, чтобы облегчить отладку вашего кода. Вот несколько доступных опций:

* +set reload+: презагрузить исходный код при изменении.
* +set autolist+: Запускать команду +list+ на каждой точке останова.
* +set listsize _n_+: Установить количество линий кода для отображения по умолчанию _n_.
* +set forcestep+: Убеждаться, что команды +next+ и +step+ всегда переходят на новую линию

Можно просмотреть полный перечень, используя +help set+. Используйте +help set _subcommand_+ для изучения определенной команды +set+.

TIP: Любые эти настройки можно включить в файл +.rdebugrc+ в директории HOME. ruby-debug считывает этот файл каждый раз, как загружается, и настраивает себя соответствующе.

Вот хорошее начало для +.rdebugrc+:

<shell>
set autolist
set forcestep
set listsize 25
</shell>
