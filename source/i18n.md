API интернационализации Rails (I18n)
====================================

В Ruby гем I18n (краткое наименование для _internationalization_),  поставляемый с Ruby on Rails (начиная с Rails 2.2), представляет простой и расширяемый фреймворк для **перевода вашего приложения на отдельный другой язык**, иной чем английский, или для **предоставления поддержки многоязычности** в вашем приложении.

Процесс "интернационализация" обычно означает извлечение всех строк и других специфичных для локали частей (таких как форматы даты и валюты) за рамки вашего приложения. Процесс "локализация" означает предоставление переводов и локализованных форматов для этих частей.

Таким образом, в процессе _интернационализации_ своего приложения на Rails вы должны:

* Убедиться, что есть поддержка i18n.
* Сказать Rails где найти словари локали.
* Сказать Rails как устанавливать, сохранять и переключать локали.

В процессе _локализации_ своего приложения вы, скорее всего, захотите сделать три вещи:

* Заменить или дополнить локаль Rails по умолчанию - т.е. форматы даты и времени, названия месяцев, имена модели Active Record и т.д.
* Извлечь строки в вашем приложении в словари ключей - т.е. сообщения flash, статичные тексты в ваших вьюхах и т.д.
* Где-нибудь хранить получившиеся словари.

Это руководство проведет вас через I18n API, оно содержит консультации как интернационализировать приложения на Rails с самого начала.

NOTE: Фреймворк Ruby I18n предоставляет вам все необходимое для интернационализации/локализации вашего приложения на Rails. Однако, можете использовать другие различные доступные плагины и расширения, добавляющие дополнительные функциональность или особенности. Больше информации содержится в the Rails [I18n Wiki](http://rails-i18n.org/wiki).

Как работает I18n в Ruby on Rails
---------------------------------

Интернационализация - это сложная проблема. Естественные языки отличаются во многих отношениях (например, в правилах образования множественного числа), поэтому трудно предоставить инструменты, решающие сразу все проблемы. По этой причине Rails I18n API сфокусировано на:

* предоставления полной поддержки для английского и подобных ему языков
* легкой настраиваемости и полном расширении для других языков

Как часть этого решения, **каждая статичная строка в фреймворке Rails** - например, валидационные сообщения Active Record, форматы времени и даты - **стали интернационализированными**, поэтому _локализация_ приложения на Rails означает "переопределение" этих значений по умолчанию.

### Общая архитектура библиотеки

Таким образом, Ruby гем I18n разделен на две части:

* Публичный API фреймворка i18n - модуль Ruby с публичными методами, определяющими как работает библиотека
* Бэкенд по умолчанию (который специально называется _простым_ бэкендом), реализующий эти методы

Как у пользователя, у вас всегда будет доступ только к публичным методам модуля I18n, но полезно знать о возможностях бэкенда.

NOTE: Возможно (или даже желательно) поменять встроенный простой бэкенд на более мощный, который будет хранить данные перевода в реляционной базе данных, словаре GetText и тому подобном. Смотрите раздел [Использование различных бэкендов](#customize-your-i18n-setup).

### Публичный I18n API

Наиболее важными методами I18n API являются:

```ruby
translate # Ищет перевод текстов
localize  # Локализует объекты даты и времени в форматы локали
```

Имеются псевдонимы #t и #l, их можно использовать следующим образом:

```ruby
I18n.t 'store.title'
I18n.l Time.now
```

Также имеются методы чтения и записи для следующих атрибутов:

```ruby
load_path         # Анонсировать ваши пользовательские файлы с переводом
locale            # Получить и установить текущую локаль
default_locale    # Получить и установить локаль по умолчанию
exception_handler # Использовать иной exception_handler
backend           # Использовать иной бэкенд
```

Итак, давайте интернационализуем простое приложение на Rails с самого начала, в следующих главах!

(customize-your-i18n-setup) Настройка приложения на Rails для интернационализации
-----------------------------------------------------

Лишь несколько шагов отделяют вас от получения и запуска поддержки I18n в вашем приложении.

### Конфигурирование модуля I18n

Следуя философии примата _соглашений над конфигурацией_, Rails настроит ваше приложение приемлемыми значениями по умолчанию. Если вам необходимы иные настройки, можете просто переписать их.

Rails автоматически добавляет все файлы `.rb` и `.yml` из директории `config/locales` к вашему **пути загрузки переводов.**

Локаль по умолчанию `en.yml` в этой директории содержит образец строки перевода:

```ruby
en:
  hello: "Hello world"
```

Это означает, что в локале `:en`, ключ _hello_ связан со строкой _"Hello world"_. Каждая строка в Rails интернационализируется подобным образом, смотрите, к примеру, валидационные сообщения Active Record в файле [`activerecord/lib/active_record/locale/en.yml`](http://github.com/rails/rails/blob/master/activerecord/lib/active_record/locale/en.yml) или форматы времени и даты в файле [`activesupport/lib/active_support/locale/en.yml`](http://github.com/rails/rails/blob/master/activesupport/lib/active_support/locale/en.yml). Для хранения переводов в бэкенде по умолчанию (простом) можете использовать YAML или стандартные хэши Ruby.

Библиотека I18n будет использовать **английский** как **локаль по умолчанию**, т.е., если не хотите установить иную локаль, при поиске переводов будет использоваться `:en`.

NOTE: В библиотеке i18n принят **прагматичный подход** к ключам локали (после [некоторых обсуждений](http://groups.google.com/group/rails-i18n/browse_thread/thread/14dede2c7dbe9470/80eec34395f64f3c?hl=en)), включающий только  часть _локаль_ ("язык"), наподобие `:en`, `:pl`, но не часть _регион_, подобно `:en-US` или `:en-GB`, как традиционно используется для разделения "языков" и "региональных настроек", или "диалектов". Многие международные приложения используют только элемент "язык" локали, такой как `:cs`, `:th` или `:es` (для Чехии, Тайланда и Испании).  Однако, также имеются региональные различия внутри языковой группы, которые могут быть важными. Например, в локали `:en-US` как символ валюты будет $, а в `:en-GB` будет £. Ничто не остановит вас от разделения региональных и других настроек следующим образом: предоставляете полную локаль "English - United Kingdom" в словаре `:en-GB`. Различные [плагины Rails I18n](http://rails-i18n.org/wiki), такие как [Globalize3](https://github.com/svenfuchs/globalize3), помогут это осуществить.

Путь **загрузки переводов** (`I18n.load_path`) - это всего лишь Ruby-массив путей к вашим файлам перевода, которые будут загружены автоматически и будут доступны в вашем приложении. Так что можете подобрать такую схему директорий и именования файлов, которая вам подходит.

NOTE: Бэкенд лениво загружет эти переводы, когда ищет перевод в первый раз. Это дает возможность переключить бэкенд на что-то иное даже после того, как переводы были объявлены.

В файлах `application.rb` по умолчанию есть инструкция, как добавлять локали из другой директории, и как настраивать другую локаль по умолчанию. Просто раскомментируйте и отредактируйте определенные строки.

```ruby
# The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
# config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
# config.i18n.default_locale = :de
```

### Опционально: Произвольная настройка конфигурации I18n

Для полноты картины, давайте отметим, что если не хочется по каким-то причинам использовать `application.rb`, также всегда можно все настроить вручную.

Чтобы сообщить библиотеке I18n, где она может найти ваши произвольные файлы перевода, можете определить путь загрузки где угодно в вашем приложении - просто убедитесь, что это будет выполнено до того, как какие-либо переводы будут фактически искаться. Таким же образом можно изменить локаль по умолчанию. Самым простым будет поместить следующее в инициализатор:

```ruby
# in config/initializers/locale.rb

# говорим библиотеке I18n, где искать наши переводы
I18n.load_path `= Dir[Rails.root.join('lib', 'locale', '*.{rb,yml}')]

# устанавливаем локаль по умолчанию на что-либо другое, чем :en
I18n.default_locale = :pt
```

### Назначение и передача локали

Если хотите перевести свое приложение на Rails на **один язык, отличный от английского** (локали по умолчанию), можете настроить I18n.default_locale на свою локаль в `application.rb` или инициализаторе, как показано выше, и это будет сохранено во всех запросах.

Однако, вы можете захотеть **предоставить поддержку для нескольких локалей** в своем приложении. В этом случае нужно установить и передать локаль между запросами.

WARNING: Вы можете попытаться хранить выбранную локаль в _сессии_ или в _куки_, однако **не делайте так**. Локаль должна быть понятной и являться частью URL. Таким образом вы не разрушите основные допущения людей о вебе: если посылаете URL друзьям, они увидят ту же страницу, то же содержимое. Иногда есть исключения из этого правила, которые мы обсудим ниже.

_Назначающая часть_ проста. Можно назначить локаль в `before_action` в `ApplicationController`, как тут:

```ruby
before_action :set_locale

def set_locale
  I18n.locale = params[:locale] || I18n.default_locale
end
```

Это требует, чтобы вы передали локаль как параметр запроса URL, как в `http://example.com/books?locale=pt`. (Это, к примеру, подход Гугла.) Таким образом, `http://localhost:3000?locale=pt` загрузит португальскую локализацию, в то время как `http://localhost:3000?locale=de` загрузит немецкую локализацию, и так далее. Можете опустить следующий раздел и перейти к разделу **Интернационализация вашего приложения**, если хотите все пробовать с помощью ручной замены локали в URL и перезагрузки страницы.

Конечно, вы не хотите вручную включать локаль в каждом URL своего приложения, или хотите, чтобы URL выглядел по-разному, т.е. `http://example.com/pt/books` против `http://example.com/en/books`. Давайте обсудим различные опции, которые у нас есть.

### Назначение локали из имени домена

Одним из вариантов, которым можно установить локаль, является доменное имя, на котором запущено ваше приложение. Например, мы хотим, чтобы `www.example.com` загружал английскую локаль (по умолчанию), а `www.example.es` загружал испанскую локаль. Таким образом, _доменное имя верхнего уровня_ используется для установки локали. В этом есть несколько преимуществ:

* Локаль является _явной_ частью URL.
* Люди интуитивно понимают, на каком языке будет отражено содержимое.
* Это очень просто реализовать в Rails.
* Поисковые движки любят, когда содержимое на различных языках живет на отдельных, взаимосвязанных доменах.

Это осуществляется так в `ApplicationController`:

```ruby
before_action :set_locale

def set_locale
  I18n.locale = extract_locale_from_tld || I18n.default_locale
end

# Получаем локаль из домена верхнего уровня или возвращаем nil, если такая локаль недоступна
# Вам следует поместить что-то наподобие этого:
#   127.0.0.1 application.com
#   127.0.0.1 application.it
#   127.0.0.1 application.pl
# в ваш файл /etc/hosts, чтобы попробовать это локально
def extract_locale_from_tld
  parsed_locale = request.host.split('.').last
  I18n.available_locales.include?(parsed_locale.to_sym) ? parsed_locale  : nil
end
```

Также можно назначить локаль из _поддомена_ похожим образом:

```ruby
# Получаем код локали из поддомена запроса (подобно http://it.application.local:3000)
# Следует поместить чтото вроде:
#   127.0.0.1 gr.application.local
# в ваш файл /etc/hosts, чтобы попробовать это локально
def extract_locale_from_subdomain
  parsed_locale = request.subdomains.first
  I18n.available_locales.include?(parsed_locale.to_sym) ? parsed_locale : nil
end
```

Если ваше приложение включает меню переключения локали, вам следует иметь что-то вроде этого в нем:

```ruby
link_to("Deutsch", "#{APP_CONFIG[:deutsch_website_url]}#{request.env['REQUEST_URI']}")
```

предполагая, что вы установили `APP_CONFIG[:deutsch_website_url]` в некоторое значение, наподобие `http://www.application.de`.

У этого решения есть вышеупомянутые преимущества, однако возможно, что вам нельзя или вы не хотите предоставить разные локализации ("языковые версии") на разные доменах. Наиболее очевидным решением является включить код локали в параметры URL (или пути запроса).

### Назначение локали из параметров URL

Наиболее обычным способом назначения (и передачи) локали будет включение ее в параметры URL, как мы делали в `I18n.locale = params[:locale]` в _before_action_ в первом примере. В этом случае нам нужны URL, такие как `www.example.com/books?locale=ja` или `www.example.com/ja/books`.

В этом подходе есть почти тот же набор преимуществ, как и в назначении локали из имени домена, а именно то, что это RESTful и соответствует остальной части Всемирной паутины. Хотя внедрение этого потребует немного больше работы.

Получение локали из `params` и соответственное назначение ее не сложно: включаете ее в каждый URL, и таким образом **передаете ее через запросы**. Конечно, включение явной опции в каждый URL (т.е. `link_to( books_url(locale: I18n.locale))`) было бы утомительно и, вероятно, невозможно.

Rails содержит инфраструктуру для "централизации динамических решений об URL" в его [`ApplicationController#default_url_options](http://api.rubyonrails.org/classes/ActionController/Base.html#M000515), что полезно в этом сценарии: он позволяет нам назначить "defaults" для [`url_for`](http://api.rubyonrails.org/classes/ActionController/Base.html#M000503) и методов хелпера, основанных на нем (с помощью применения/переопределения этого метода).

Затем мы можем включить что-то наподобие этого в наш `ApplicationController`:

```ruby
# app/controllers/application_controller.rb
def default_url_options(options={})
  logger.debug "default_url_options is passed options: #{options.inspect}\n"
  { locale: I18n.locale }
end
```

Каждый метод хелпера, зависимый от `url_for` (т.е. хелперы для именнованных маршрутов, такие как `root_path` или `root_url`, ресурсные маршруты, такие как `books_path` или `books_url` и т.д.) теперь будут **автоматически включать локаль в строку запроса**, как тут: `http://localhost:3001/?locale=ja`.

Это может быть достаточным. Хотя и влияет на читаемость URL, когда локаль "висит" в конце каждого URL вашего приложения. Более того, с точки зрения архитектуры, локаль иерархически выше остальных частей домена приложения, и URL должен отражать это.

Вы, возможно, захотите, чтобы URL выглядел так: `www.example.com/en/books` (который загружает английскую локаль) и `www.example.com/nl/books` (который загружает голландскую локаль). Это достижимо с помощью такой же стратегии, как и с `default_url_options` выше: нужно настроить свои маршруты с помощью опции [`scoping`](http://api.rubyonrails.org/classes/ActionDispatch/Routing/Mapper/Scoping.html) следующим образом:

```ruby
# config/routes.rb
scope "/:locale" do
  resources :books
end
```

Теперь, когда вы вызовите метод `books_path`, то получите `"/en/books"` (для локали по умолчанию). URL подобный `http://localhost:3001/nl/books` загрузит голландскую локаль, и затем, последующий вызов `books_path` возвратит `"/nl/books"` (поскольку локаль изменилась).

Если не хотите принудительно использовать локаль в своих маршрутах, можете использовать опциональную область пути (заключенную в скобки), как здесь:

```ruby
# config/routes.rb
scope "(:locale)", locale: /en|nl/ do
  resources :books
end
```

С таким подходом вы не получите `Routing Error` при доступе к своим ресурсам как `http://localhost:3001/books` без локали. Это полезно, когда хочется использовать локаль по умолчанию, если она не определена.

Конечно, нужно специально позаботиться о корневом URL (это обычно "домашняя страница" или "лицевая панель") вашего приложения. URL, такой как `http://localhost:3001/nl` не заработает автоматически, так как объявление `root to: "books#index"` в вашем `routes.rb` не принимает локаль во внимание. (И правильно делает: может быть только один "корневой" URL.)

Вам, вероятно, потребуется связать URL так:

```ruby
# config/routes.rb
match '/:locale' => 'dashboard#index'
```

Особенно побеспокойтесь относительно *порядка ваших маршрутов*, чтобы одно объявление маршрутов не "съело" другое. (Вы, возможно, захотите добавить его непосредственно перед объявлением `root :to`.)

NOTE: У этого решения есть один довольно большой *недостаток*. Благодаря применению _"default_url_options"_, вам нужно указывать опцию `:id` явно, как тут: `link_to 'Show', book_url(:id => book)`, не зависимо от магии Rails в таком коде `link_to 'Show', book`. Если это будет проблемой, обратите внимание на два плагина, упрощающих работу с маршрутами в этом случае: Sven Fuchs's [routing_filter](http://github.com/svenfuchs/routing-filter/tree/master) и Raul Murciano's [translate_routes](http://github.com/raul/translate_routes/tree/master). Также посмотрите страницу [How to encode the current locale in the URL](http://rails-i18n.org/wiki/wikipages/how-to-encode-the-current-locale-in-the-url) в Rails i18n Wiki.

### Указание локали из информации, предоставленной клиентом

В одельных случаях имеет смысл назначить локаль на основе информации, полученной от клиента, т.е. не из URL. Эта информация может исходить, например, от предпочитаемого пользователем языка (установленного в его браузере), может быть основана на географическом положении пользователя на основе его IP, или пользователи могут предоставить ее, просто указав локаль в своем интерфейсе приложения и сохранив ее в своем профиле. Этот подход более подходит для основанных на веб приложений или сервисов, а не для веб-сайтов - смотрите врезку о _сессиях_, _куки_ и архитектуре RESTful, указанную выше.

#### Использование `Accept-Language`

Одним из источников информации о клиенте является HTTP заголовок `Accept-Language`. Можно [настроить его в своем браузере](http://www.w3.org/International/questions/qa-lang-priorities) или другом клиенте (таком как _curl_).

Обычной реализацией использования заголовка `Accept-Language` будет следующее:

```ruby
def set_locale
  logger.debug "* Accept-Language: #{request.env['HTTP_ACCEPT_LANGUAGE']}"
  I18n.locale = extract_locale_from_accept_language_header
  logger.debug "* Locale set to '#{I18n.locale}'"
end
private
def extract_locale_from_accept_language_header
  request.env['HTTP_ACCEPT_LANGUAGE'].scan(/^[a-z]{2}/).first
end
```

Конечно, в рабочей среде нужен более надежный код, можете использовать плагин, такой как Iain Hecker's [http_accept_language](http://github.com/iain/http_accept_language/tree/master) или даже промежуточное приложение Rack, такое как Ryan Tomayko's [locale](http://github.com/rtomayko/rack-contrib/blob/master/lib/rack/locale.rb).

#### Использование базы данных GeoIP (или подобной)

Другим способом выбора локали по клиентской информации может быть использование базы данных для связывания IP клиента с регионом, такой как [GeoIP Lite Country](http://www.maxmind.com/app/geolitecountry). Механизм кода будет очень похож на код выше - нужно запросить у базы данных пользовательский IP, и найти предпочитаемую локаль для возвращенных страны/региона/города.

#### Профиль пользователя

Можно также предоставить пользователям приложения возможность назначать (или менять) локаль в интерфейсе приложения. И снова, механизм этого подхода очень похож на код выше - вы, возможно, позволите пользователю выбрать локаль из списка и сохраните ее в его профиле в базе данных. Затем вы установите локаль в это значение.

Интернационализация вашего приложения
-------------------------------------

Хорошо! Вы уже инициализировали поддержку I18n в своем приложении на Ruby on Rails, и сообщили ему, какую локаль использовать, и как ее сохранять между запросами. С этого момента мы готовы к действительно интересным вещам.

Давайте _интернационализируем_ наше приложение, т.е. абстрагируем каждую специфичную к локали часть, а затем _локализуем_ его, т.е. предоставим необходимые переводы для этих абстракций:

Скорее всего у вас есть что-то подобное в одном из ваших приложений:

```ruby
# config/routes.rb
Yourapp::Application.routes.draw do
  root to: "home#index"
end
```

```ruby
# app/controllers/home_controller.rb
class HomeController < ApplicationController
  def index
    flash[:notice] = "Hello Flash"
  end
end
```

```html+erb
# app/views/home/index.html.erb
<h1>Hello World</h1>
<p><%= flash[:notice] %></p>
```

![непереведенная демонстрация rails i18n](/assets/guides/demo_untranslated.png)

### Добавление переводов

Очевидно, что у нас есть **две строки, локализованные на английском**. Чтобы интернационализировать этот код, **замените эти строки** вызовами хелпера Rails `#t` с имеющим смысл для перевода ключом:

```ruby
# app/controllers/home_controller.rb
class HomeController < ApplicationController
  def index
    flash[:notice] = t(:hello_flash)
  end
end
```

```html+erb
# app/views/home/index.html.erb
<h1><%=t :hello_world %></h1>
<p><%= flash[:notice] %></p>
```

Теперь при рендере вьюхи будет показано сообщение об ошибке, сообщающее, что отсутствуют переводы для ключей `:hello_world` и `:hello_flash`.

![демонстрация отсутствия перевода в rails i18n](/assets/guides/demo_translation_missing.png)

NOTE: Rails добавляет метод хелпера `t` (`translate`) во вьюхи, так что вам не нужно впечатывать `I18n.t` каждый раз. Дополнительно этот хелпер ловит отсутствующие переводы и  оборачивает результирующее сообщение об ошибке в `&lt;span class="translation_missing"&gt;`.

Давайте добавим отсутствующие переводы в файлы словарей (т.е. выполним часть "локализация"):

```yaml
# config/locales/en.yml
en:
  hello_world: Hello world!
  hello_flash: Hello flash!

# config/locales/pirate.yml
pirate:
  hello_world: Ahoy World
  hello_flash: Ahoy Flash
```

Продолжим. Так как мы не сменили default_locale, I18n будет использовать английский. Теперь ваше приложение покажет:

![пример rails i18n, переведенный на английский](/assets/guides/demo_translated_en.png)

А когда вы измените URL, чтобы передать пиратскую локаль (`http://localhost:3000?locale=pirate`), то получите:

![пример rails i18n, переведенный на пиратский](/assets/guides/demo_translated_pirate.png)

NOTE: Нужно перезагрузить сервер после того, как вы добавили новые файлы локали.

Для хранения переводов в SimpleStore можно использовать файлы YAML (`.yml`) или чистого Ruby (`.rb`). YAML является наиболее предпочитаемым вариантом среди разработчиков Rails. Однако у него есть один большой недостаток. YAML очень чувствителен к пробелам и спецсимволам, поэтому приложение может неправильно загрузить ваш словарь. Файлы Ruby уронят ваше приложение при первом же обращении, поэтому вам будет просто найти, что в них неправильно. (Если возникают "странности" со словарями YAML, попробуйте поместить соответствующие части словаря в файл Ruby.)

### Передача переменных в переводы

Можно использовать переменные в переводимых сообщениях, и передавать их значения из вьюхи.

```erb
# app/views/home/index.html.erb
<%=t 'greet_username', user: "Bill", message: "Goodbye" %>
```

```yaml
# config/locales/en.yml
en:
  greet_username: "%{message}, %{user}!"
```

### Добавление форматов даты/времени

Хорошо! Теперь давайте добавим временную метку во вьюху, чтобы продемонстрировать особенности **локализации даты/времени**. Чтобы локализовать формат даты, нужно передать объект Time в `I18n.l`, или (лучше) использовать хелпер Rails `#l`. Формат можно выбрать передав опцию `:format` - по умолчанию используется формат `:default`.

```erb
# app/views/home/index.html.erb
<h1><%=t :hello_world %></h1>
<p><%= flash[:notice] %></p
<p><%= l Time.now, format: :short %></p>
```

И в нашем файле переводов на пиратский давайте добавим формат времени (в Rails уже есть формат по умолчанию для английского):

```ruby
# config/locales/pirate.yml
pirate:
  time:
    formats:
      short: "arrrround %H'ish"
```

Что даст вам:

![демонстрация локализации времени rails i18n на пиратский](/assets/guides/demo_localized_pirate.png)

TIP: Сейчас вам, возможно, захочется добавить больше форматов для того, чтобы бэкенд I18n работал как нужно (как минимум для локали "pirate"). Конечно, есть большая вероятность, что кто-то еще выполнил всю работу по **переводу значений по умолчанию Rails для вашей локали**. Смотрите в [репозитории rails-i18n на Github](http://github.com/svenfuchs/rails-i18n/tree/master/rails/locale) архив с различными файлами локали. Когда вы поместите такой файл(ы) в директорию `config/locales/`, они автоматически станут готовыми для использования.

### Правила словообразования для других локалей

Rails 4.0 позволяет определить правила словообразования (такие как единственое и множественное число) для локалец, отличных от английской. В `config/initializers/inflections.rb` можно определить эти правила для нескольких локалей. Инициализатор содержит пример по умолчанию для определения дополнительных правил для английского; следуйте этому формату для других локалей.

### Локализованные вьюхи

Rails 2.3 представил другую удобную особенность локализации: локализованные вьюхи (шаблоны). Скажем, у вас в приложении есть _BooksController_. Экшн _index_ рендерит содержимое в шаблоне `app/views/books/index.html.erb`. Когда вы помещаете _локализованный вариант_ этого шаблона: **`index.es.html.erb`** в ту же директорию, Rails будет рендерить содержимое в этот шаблон, когда локаль будет установлена как `:es`. Когда будет установлена локаль по умолчанию, будет использована обычная вьюха `index.html.erb`. (Будущие версии Rails, возможно, перенесут эту возможность _автоматической_ локализации на файлы в `public`, и т.д.)

Можете использовать эту особенность, например, при работе с большим количеством статичного содержимого, который было бы неудобно вложить в словари YAML или Ruby. Хотя имейте в виду, что любое изменение, которое вы в дальнейшем сделаете в шаблоне, должно быть распространено на все локали.

### Организация файлов локали

При использовании дефолтного SimpleStore вместе с библиотекой i18n, словари хранятся в текстовых файлах на диске. Помещение переводов ко всем частям приложения в один файл на локаль будет трудным для управления. Можно хранить эти файлы в иерархии, которая будет для вас понятной.

К примеру, ваша директория `config/locales` может выглядеть так:

```
|-defaults
|---es.rb
|---en.rb
|-models
|---book
|-----es.rb
|-----en.rb
|-views
|---defaults
|-----es.rb
|-----en.rb
|---books
|-----es.rb
|-----en.rb
|---users
|-----es.rb
|-----en.rb
|---navigation
|-----es.rb
|-----en.rb
```

Таким образом можно разделить модель и имена атрибутов модели от текста внутри вьюх, и все это от "defaults" (т.е. форматов даты и времени). Другие хранилища для библиотеки i18n могут предоставить другие средства подобного разделения.

NOTE: Механизм загрузки локали по умолчанию в Rails не загружает файлы локали во вложенных словарях, как тут. Поэтому, чтобы это заработало, нужно явно указать Rails смотреть глубже:

```ruby
  # config/application.rb
  config.i18n.load_path += Dir[Rails.root.join('config', 'locales', '**', '*.{rb,yml}')]
```

Обратите внимание на [Rails i18n Wiki](http://rails-i18n.org/wiki), там есть перечень инструментов для управления переводами.

Обзор особенностей I18n API
---------------------------

Теперь у вас есть хорошее понимание об использовании библиотеки i18n, знания всех необходимых аспектов интернационализации простого приложения на Rails. В следующих частях мы раскроем особенности более детально.

Раскроем особенности такие, как:

* поиск переводов
* интерполяция данных в переводы
* множественное число у переводов
* использование HTML-безопасных переводов
* локализация дат, номеров, валют и т.п.

### Поиск переводов

#### Основы поиска, области имен и вложенных ключей

Переводы ищутся по ключам, которые могут быть как символами, так и строками, поэтому следующие вызовы эквивалентны:

```ruby
I18n.t :message
I18n.t 'message'
```

Метод `translate` также принимает опцию `:scope`, которая содержит один или более дополнительных ключей, которые будут использованы для определения “пространства” или области имен для ключа перевода:

```ruby
I18n.t :record_invalid, scope: [:activerecord, :errors, :messages]
```

Тут будет искаться сообщение `:record_invalid` в сообщениях об ошибке Active Record.

Кроме того, и ключ, и область имен могут быть определены как ключи с точкой в качестве разделителя, как в:

```ruby
I18n.translate "activerecord.errors.messages.record_invalid"
```

Таким образом, следующие вызовы эквивалентны:

```ruby
I18n.t 'activerecord.errors.messages.record_invalid'
I18n.t 'errors.messages.record_invalid', scope: :active_record
I18n.t :record_invalid, scope: 'activerecord.errors.messages'
I18n.t :record_invalid, scope: [:activerecord, :errors, :messages]
```

#### Значения по умолчанию

Когда задана опция `:default`, будет возвращено ее значение в случае, если отсутствует перевод:

```ruby
I18n.t :missing, default: 'Not here'
# => 'Not here'
```

Если значение `:default` является символом, оно будет использовано как ключ и будет переведено. Может быть представлено несколько значений по умолчанию. Будет возвращено первое, которое даст результат.

Т.е., следующее попытается перевести ключ `:missing`, затем ключ `:also_missing`. Если они оба не дадут результат, будет возвращена строка "Not here":

```ruby
I18n.t :missing, default: [:also_missing, 'Not here']
# => 'Not here'
```

#### Массовый поиск и поиск в пространстве имен

Чтобы найти несколько переводов за раз, может быть передан массив ключей:

```ruby
I18n.t [:odd, :even], scope: 'errors.messages'
# => ["must be odd", "must be even"]
```

Также, ключ может перевести хэш (потенциально вложенный) сгруппированных переводов. Т.е. следующее получит _все_ сообщения об ошибке Active Record как хэш:

```ruby
I18n.t 'activerecord.errors.messages'
# => {:inclusion=>"is not included in the list", :exclusion=> ... }
```

#### "Ленивый" поиск

Rails реализует удобный способ поиска локали внутри _вьюх_. Когда имеется следующий словарь:

```yaml
es:
  books:
    index:
      title: "Título"
```

можно найти значение `books.index.title` **в** шаблоне `app/views/books/index.html.erb` таким образом (обратите внимание на точку):

```ruby
<%= t '.title' %>
```

### Интерполяция

Во многих случаях хочется абстрагировать свои переводы так, чтобы **переменные могли быть интерполированы в переводы**. В связи с этим, API I18n предоставляет особенность интерполяции.

Все опции, кроме `:default` и `:scope`, которые передаются в `#translate`, будут интерполированы в перевод:

```ruby
I18n.backend.store_translations :en, thanks: 'Thanks %{name}!'
I18n.translate :thanks, name: 'Jeremy'
# => 'Thanks Jeremy!'
```

Если перевод использует `:default` или `:scope` как интерполяционную переменную, будет вызвано исключение `I18n::ReservedInterpolationKey`. Если перевод ожидает интерполяционную переменную, но она не была передана в `#translate`, вызовется исключение `I18n::MissingInterpolationArgument`.

### Множественное число

В английском только одна форма единственного числа, и одна множественного для заданной строки, т.е. "1 message" и "2 messages". В других языках ([русском](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html#ru), [арабском](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html#ar), [японском](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html#ja) и многих других) имеются различные правила грамматики, имеющие дополнительные или остутствующие [формы множественного числа](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html). Таким образом, API I18n предоставляет гибкую возможность множественных форм.

У переменной интерполяции `:count` есть специальная роль в том, что она интерполируется для перевода, и используется для подбора множественного числа для перевода в соответствии с правилами множественного числа, определенными в CLDR:

```ruby
I18n.backend.store_translations :en, inbox: {
  one: 'one message',
  other: '%{count} messages'
}
I18n.translate :inbox, count: 2
# => '2 messages'

I18n.translate :inbox, count: 1
# => 'one message'
```

Алгоритм для образования множественного числа в `:en` прост:

```ruby
entry[count == 1 ? 0 : 1]
```

Т.е., перевод помеченный как `:one`, рассматривается как единственное число, все другое как множественное (включая ноль).

Если поиск по ключу не возвратит хэш, подходящий для образования множественного числа, вызовется исключение `18n::InvalidPluralizationData`.

### Настройка и передача локали

Локаль может быть либо установленной псевдо-глобально в `I18n.locale` (когда используется `Thread.current`, например `Time.zone`), либо быть переданной опцией в `#translate` и `#localize`.

Если локаль не была передана, используется `I18n.locale`:

```ruby
I18n.locale = :de
I18n.t :foo
I18n.l Time.now
```

Явно переданная локаль:

```ruby
I18n.t :foo, locale: :de
I18n.l Time.now, locale: :de
```

Умолчанием для `I18n.locale` является `I18n.default_locale`, для которой по умолчанию установлено `:en`. Локаль по умолчанию может быть установлена так:

```ruby
I18n.default_locale = :de
```

### Использование HTML-безопасных переводов

Ключи с суффиксом '_html' и ключами с именем 'html' помечаются как HTML-безопасные. Их можно использовать во вьюхах без экранирования.

```yaml
# config/locales/en.yml
en:
  welcome: <b>welcome!</b>
  hello_html: <b>hello!</b>
  title:
    html: <b>title!</b>
```

```erb
# app/views/home/index.html.erb
<div><%= t('welcome') %></div>
<div><%= raw t('welcome') %></div>
<div><%= t('hello_html') %></div>
<div><%= t('title.html') %></div>
```

![демонстрация html-безопасности в i18n](/assets/guides/i18n_demo_html_safe.png)

Как хранить свои переводы
-------------------------

Простой бэкенд, поставляющийся вместе с Active Support, позволяет хранить переводы как в формате чистого Ruby, так и в YAML. (Другие бэкенды могут позволить или требовать использование иных форматов, например GetText позволяет использовать формат GetText.)

Например, представляющий перевод хэш Ruby выглядит так:

```ruby
{
  pt: {
    foo: {
      bar: "baz"
    }
  }
}
```

Эквивалентный файл YAML выглядит так:

```yaml
pt:
  foo:
    bar: baz
```

Как видите, в обоих случаях ключ верхнего уровня является локалью. `:foo` - это ключ пространства имен, а `:bar` - это ключ для перевода "baz".

Вот "реальный" пример из YAML файла перевода Active Support `en.yml`:

```yaml
en:
  date:
    formats:
      default: "%Y-%m-%d"
      short: "%b %d"
      long: "%B %d, %Y"
```

Таким образом, все из нижеследующих эквивалентов возвратит краткий (`:short`) формат даты `"%b %d"`:

```ruby
I18n.t 'date.formats.short'
I18n.t 'formats.short', scope: :date
I18n.t :short, scope: 'date.formats'
I18n.t :short, scope: [:date, :formats]
```

Как правило мы рекомендуем использовать YAML как формат хранения переводов. Хотя имеются случаи, когда хочется хранить лямбда-функции Ruby как часть данных локали, например, для специальных форматов дат.

### Переводы для моделей Active Record

Можете использовать методы `Model.human_name` и `Model.human_attribute_name(attribute)` для прозрачного поиска переводов для ваших моделей и имен атрибутов.

Например, когда добавляем следующие переводы:

```yaml
en:
  activerecord:
    models:
      user: Dude
    attributes:
      user:
        login: "Handle"
      # will translate User attribute "login" as "Handle"
```

Тогда `User.human_name` возвратит "Dude", а `User.human_attribute_name("login")` возвратит "Handle".

#### Пространства имен сообщений об ошибке

Сообщение об ошибке валидации Active Record также может быть легко переведено. Active Record предоставляет ряд пространств имен, куда можно поместить ваши переводы для передачи различных сообщений и переводы для определенных моделей, аттрибутов и/или валидаций. Также учитывается одиночное наследование таблицы (single table inheritance).

Это дает довольно мощное средство для гибкой настройки ваших сообщений в соответствии с потребностями приложения.

Рассмотрим модель User с валидацией `validates_presence_of` для атрибута name, подобную следующей:

```ruby
class User < ActiveRecord::Base
  validates :name, presence: true
end
```

Ключом для сообщения об ошибке в этом случае будет `:blank`. Active Record будет искать этот ключ в пространствах имен:

```ruby
activerecord.errors.models.[model_name].attributes.[attribute_name]
activerecord.errors.models.[model_name]
activerecord.errors.messages
errors.attributes.[attribute_name]
errors.messages
```

Таким образом, в нашем примере он будет перебирать следующие ключи в указанном порядке и возвратит первый полученный результат:

```ruby
activerecord.errors.models.user.attributes.name.blank
activerecord.errors.models.user.blank
activerecord.errors.messages.blank
errors.attributes.name.blank
errors.messages.blank
```

Когда ваши модели дополнительно используют наследование, тогда сообщения ищутся в цепочке наследования.

Например, у вас может быть модель Admin, унаследованная от User:

```ruby
class Admin < User
  validates :name, presence: true
end
```

Тогда Active Record будет искать сообщения в этом порядке:

```ruby
activerecord.errors.models.admin.attributes.name.blank
activerecord.errors.models.admin.blank
activerecord.errors.models.user.attributes.name.blank
activerecord.errors.models.user.blank
activerecord.errors.messages.blank
errors.attributes.name.blank
errors.messages.blank
```

Таким образом можно предоставить специальные переводы для различных сообщений об ошибке в различных местах цепочки наследования моделей и в атрибутах, моделях и пространствах имен по умолчанию.

#### Интерполяция сообщения об ошибке

Переведенное имя модели, переведенное имя атрибута и значение всегда доступны для интерполяции.

Так, к примеру, вместо сообщения об ошибке по умолчанию `"can not be blank"` можете использовать имя атрибута как тут: `"Please fill in your %{attribute}"`.

* Где это возможно, `count` может быть использован для множественного числа, если оно существует:

| валидация    | с опцией                  | сообщение                 | интерполяция |
| ------------ | ------------------------- | ------------------------- | ------------ |
| confirmation | -                         | :confirmation             | -            |
| acceptance   | -                         | :accepted                 | -            |
| presence     | -                         | :blank                    | -            |
| length       | :within, :in              | :too_short                | count        |
| length       | :within, :in              | :too_long                 | count        |
| length       | :is                       | :wrong_length             | count        |
| length       | :minimum                  | :too_short                | count        |
| length       | :maximum                  | :too_long                 | count        |
| uniqueness   | -                         | :taken                    | -            |
| format       | -                         | :invalid                  | -            |
| inclusion    | -                         | :inclusion                | -            |
| exclusion    | -                         | :exclusion                | -            |
| associated   | -                         | :invalid                  | -            |
| numericality | -                         | :not_a_number             | -            |
| numericality | :greater_than             | :greater_than             | count        |
| numericality | :greater_than_or_equal_to | :greater_than_or_equal_to | count        |
| numericality | :equal_to                 | :equal_to                 | count        |
| numericality | :less_than                | :less_than                | count        |
| numericality | :less_than_or_equal_to    | :less_than_or_equal_to    | count        |
| numericality | :odd                      | :odd                      | -            |
| numericality | :even                     | :even                     | -            |

#### Переводы для хелпера Active Record `error_messages_for`

Если используете хелпер Active Record `error_messages_for`, то, возможно, захотите добавить для него переводы.

Rails поставляется со следующими переводами:

```yaml
en:
  activerecord:
    errors:
      template:
        header:
          one:   "1 error prohibited this %{model} from being saved"
          other: "%{count} errors prohibited this %{model} from being saved"
        body:    "There were problems with the following fields:"
```

NOTE: Чтобы использовать этот хелпер, необходимо установить гем [DynamicForm](https://github.com/joelmoss/dynamic_form), добаввив следующую строчку в свой Gemfile: `gem 'dynamic_form'`.

### Обзор других встроенных методов, предоставляющих поддержку I18n

Rails использует фиксированные строки и другие локализации, такие как формат строки и другая информация о формате, в ряде хелперов. Вот краткий обзор.

#### Методы хелпера Action View

* `distance_of_time_in_words` переводит и образует множественное число своего результата и интерполирует число секунд, минут, часов и т.д. Смотрите переводы [datetime.distance_in_words](http://github.com/rails/rails/blob/master/actionpack/lib/action_view/locale/en.yml#L51).
* `datetime_select` и `select_month` используют переведенные имена месяцев для заполнения результирующего тега select. Смотрите переводы в [date.month_names](http://github.com/rails/rails/blob/master/activesupport/lib/active_support/locale/en.yml#L15). `datetime_select` также ищет опцию order из [date.order](http://github.com/rails/rails/blob/master/activesupport/lib/active_support/locale/en.yml#L18) (если вы передали эту опцию явно). Все хелперы выбора даты переводят prompt, используя переводы в пространстве имен [datetime.prompts](http://github.com/rails/rails/blob/master/actionpack/lib/action_view/locale/en.yml#L83), если применимы.
* Хелперы `number_to_currency`, `number_with_precision`, `number_to_percentage`, `number_with_delimiter` и `number_to_human_size` используют настройки формата чисел в пространстве имен [number](http://github.com/rails/rails/blob/master/actionpack/lib/action_view/locale/en.yml#L2).

#### Методы Active Model

* `human_name` и `human_attribute_name` используют переводы для имен модели и имен аттрибутов, если они доступны в пространстве имен [activerecord.models](http://github.com/rails/rails/blob/master/activerecord/lib/active_record/locale/en.yml#L29). Они также предоставляют переводы для имен унаследованного класса (т.е. для использования вместе с STI), как уже объяснялось выше в "Области сообщения об ошибке".
* `ActiveModel::Errors#generate_message` (который используется валидациями Active Model, но также может быть использован вручную) использует `human_name` и `human_attribute_name` (смотрите выше). Он также переводит сообщение об ошибке и поддерживает переводы для имен унаследованного класса, как уже объяснялось выше в "Пространства имен сообщений об ошибке".
* `ActiveModel::Errors#full_messages` добавляет имя атрибута к сообщению об ошибке, используя разделитель, который берется из [errors.format](https://github.com/rails/rails/blob/master/activemodel/lib/active_model/locale/en.yml#L4) (и по умолчанию равен `"%{attribute} %{message}"`).

#### Методы Active Support

* `Array#to_sentence` использует настройки формата, которые заданы в пространстве имен [support.array](http://github.com/rails/rails/blob/master/activesupport/lib/active_support/locale/en.yml#L30).

Настройка I18n
--------------

### Использование различных бэкендов

По некоторым причинам простой бэкенд, поставляющийся с Active Support, осуществляет только "простейшие вещи, в которых возможна работа" _Ruby on Rails_ (или, цитируя Википедию, Интернационализация это процесс разработки программного обеспечения таким образом, что оно может быть адаптировано к различным языкам и регионам без существенных инженерных изменений. Локализация это процесс адаптации программы для отдельного региона или языка с помощью добавления специфичных для локали компонентов и перевод текстов), что означает то, что гарантируется работа для английского и, как побочный эффект, для схожих с английским языков. А также, простой бэкенд способен только читать переводы, а не динамически хранить их в каком-либо формате.

Впрочем, это не означает, что вы связаны этими ограничениями. Гем Ruby I18n позволяет с легкостью заменить простой бэкенд на что-то иное, более предпочтительное для ваших нужд. К примеру можно заменить его на бэкенд Globalize's Static:

```ruby
I18n.backend = Globalize::Backend::Static.new
```

Также можно использовать бэкенд Chain для связывания различных бэкендов вместе. Это полезно при использовании стандартных переводов с помощью простого бэкенда, но хранении переводов приложения в базе данных или других бэкендах. Например, можно использовать бэкенд Active Record и вернуться к простому бэкенду (по умолчанию):

```ruby
I18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)
```

### Использование различных обработчиков исключений

API I18n определяет следующие исключения, вызываемые бэкендами, когда происходят соответствующие неожидаемые условия:

```ruby
MissingTranslationData       # не обнаружен перевод для запрашиваемого ключа
InvalidLocale                # локаль, установленная I18n.locale, невалидна (например, nil)
InvalidPluralizationData     # была передана опция count, но данные для перевода не могут быть возведены во множественное число
MissingInterpolationArgument # перевод ожидает интерполяционный аргумент, который не был передан
ReservedInterpolationKey     # перевод содержит зарезервированное имя интерполяционной переменной (т.е. scope, default)
UnknownFileType              # бэкенд не знает, как обработать тип файла, добавленного в I18n.load_path
```

API I18n поймает все эти исключения, когда они были вызваны в бэкенде, и передаст их в метод default_exception_handler. Этот метод перевызовет все исключения, кроме исключений `MissingTranslationData`. Когда было вызвано исключение `MissingTranslationData`, он возвратит строку сообщения об ошибке исключения, содержащую отсутствующие ключ/пространство имен.

Причиной для этого является то, что при разработке вам обычно хочется, чтобы вьюхи рендерились несмотря на отсутствующие переводы.

Впрочем, в иных ситуациях, возможно, захочется изменить это поведение. Например, обработка исключений по умолчанию не позволяет просто ловить отсутствующие переводы во время автоматических тестов. Для этой цели может быть определен иной обработчик исключений. Определенный обработчик исключений должен быть методом в модуле I18n или классом с методом `#call`:

```ruby
module I18n
  class JustRaiseExceptionHandler < ExceptionHandler
    def call(exception, locale, key, options)
      if exception.is_a?(MissingTranslation)
        raise exception.to_exception
      else
        super
      end
    end
  end
end

I18n.exception_handler = I18n::JustRaiseExceptionHandler.new
```

Это перевызовет только исключение `MissingTranslationData`, передав все другие значения в обработчик исключений по умолчанию.

Однако, если вы используете `I18n::Backend::Pluralization`, этот обработчик также вызывает исключение `I18n::MissingTranslationData: translation missing: en.i18n.plural.rule`, которое обычно должно быть проигнорировано для отката к правилу плюрализации по умолчанию в английской локали. Чтобы это измежать, можно добавить дополнительную проверку ключа перевода:

```ruby
if exception.is_a?(MissingTranslation) && key.to_s != 'i18n.plural.rule'
  raise exception.to_exception
else
  super
end
```

Другим примером, когда поведение по умолчанию является менее желательным, является Rails TranslationHelper, который предоставляет метод `#t` (то же самое, что `#translate`). Когда в этом контексте происходит исключение `MissingTranslationData` хелпер оборачивает сообщение в span с классом CSS `translation_missing`.

Чтобы это осуществить, хелпер заставляет `I18n#translate` вызвать исключения, независимо от того, какой обработчик исключений установлен, определяя опцию `:raise`:

```ruby
I18n.t :foo, raise: true # всегда перевызывает исключения из бэкенда
```
